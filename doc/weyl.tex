% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage[top=37mm,bottom=37mm,left=27mm,right=27mm]{geometry}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{Weyl Modules}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{Weyl Modules}}
\markright{\scriptsize \mbox{}\hfill \textsf{Weyl Modules} \hfill\mbox{}}
{\Huge Version 2.0\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{S. R. Doty  \mbox{}}}\\
\hypersetup{pdfauthor=S. R. Doty  }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{S. R. Doty  }  Email: \href{mailto://doty@math.luc.edu} {\texttt{doty@math.luc.edu}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
{\copyright} 2009, 2019 S. R. Doty. 

 This package is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version. For details, see \href{https://www.gnu.org/licenses/licenses.html} {\texttt{https://www.gnu.org/licenses/licenses.html}}. 

 This software is distributed \emph{as is} without warranty of any kind, either expressed or implied, including, but not
limited to, the implied warranties of merchantability and fitness for a
particular purpose. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Weyl modules}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DA94D8C7F214621}{}
{
 This chapter discusses the commands available for computations with Weyl
modules for a given simple simply-connected algebraic group $G$ in positive characteristic $p$. Actually the group $G$ itself never appears in any of the computations, which take place instead
using the \emph{algebra of distributions} (also known as the \emph{hyperalgebra}) of $G$, taken over the prime field. One should refer to \cite{Jantzen} for the definition of the algebra of distributions, and other basic
definitions and properties related to Weyl modules. 

 The algorithms are based on the method of \cite{Irving} (see also \cite{Xi}) and build on the existing Lie algebra functionality in \textsf{GAP}. In principle, one can work with arbitrary weights for an arbitrary (simple)
root system; in practice, the functionality is limited by the size of the
objects being computed. If your Weyl module has dimension in the thousands,
you may have to wait a very long time for certain computations to finish. 

 The package is possibly most useful for doing computations in characteristic $p$ where $p$ is smaller than the Coxeter number. For such small primes, the general theory
offers very little information. 

 \emph{Warning.} At the core of many of the computations is a routine which produces a basis
for the space of maximal vectors of a specified dominant weight in a Weyl
module. Usually, that space has dimension at most 1. Cases for which there
exist two or more independent maximal vectors of the same weight could
possibly cause problems, so the code will emit an warning message if this
occurs (and then try to continue). Such situations are relatively rare (and
interesting); the smallest example known to the author occurs in Type $D_4$ in the Weyl module of highest weight [0,1,0,0], as pointed out on page 173 of \cite{CPS}. (I am grateful to Anton Cox for this reference.) See the examples in Section \ref{sec:maxvec} to see the explicit form of the warning message. 
\section{\textcolor{Chapter }{Creating Weyl modules}}\label{sec:create}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X8660D150822142AE}{}
{
  There are two functions for creating a Weyl module. 

\subsection{\textcolor{Chapter }{WeylModule}}
\logpage{[ 1, 1, 1 ]}\nobreak
\hyperdef{L}{X8559E5C5867FB091}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WeylModule({\mdseries\slshape p, lambda, t, r})\index{WeylModule@\texttt{WeylModule}}
\label{WeylModule}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WeylModule({\mdseries\slshape V, lambda})\index{WeylModule@\texttt{WeylModule}}
\label{WeylModule}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A Weyl module



 The function \texttt{WeylModule} with four arguments creates a Weyl module over a field of characteristic \mbox{\texttt{\mdseries\slshape p}}, of highest weight \mbox{\texttt{\mdseries\slshape lambda}}, for the root system of Type \mbox{\texttt{\mdseries\slshape t}} and rank \mbox{\texttt{\mdseries\slshape r}}. The type should be a string of the form ``A'' through ``G''. 

 In the second form, with two arguments, \mbox{\texttt{\mdseries\slshape V}} is an existing Weyl module and the new Weyl module has the same characteristic
and root system as the existing one. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(3, [3,4], "A", 2);|
  <Type A2 Weyl module of highest weight [ 3, 4 ] at prime p = 3>
  !gapprompt@gap>| !gapinput@W:= WeylModule(V, [3,0]);|
  <Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
\end{Verbatim}
 }

 There is also a category of Weyl modules. 

\subsection{\textcolor{Chapter }{IsWeylModule}}
\logpage{[ 1, 1, 2 ]}\nobreak
\hyperdef{L}{X7C3D6BB17AFD771C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsWeylModule({\mdseries\slshape V})\index{IsWeylModule@\texttt{IsWeylModule}}
\label{IsWeylModule}
}\hfill{\scriptsize (property)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} or \texttt{false}



 This function returns \texttt{true} iff \mbox{\texttt{\mdseries\slshape V}} is a Weyl module. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsWeylModule(W);|
  true
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Creating quotients of Weyl modules}}\label{sec:quotients}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X788C5B07860225CA}{}
{
  Quotients of Weyl modules are also supported. They are created by the
following command. 

\subsection{\textcolor{Chapter }{QuotientWeylModule}}
\logpage{[ 1, 2, 1 ]}\nobreak
\hyperdef{L}{X7893DF5B807DF77F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{QuotientWeylModule({\mdseries\slshape V, list})\index{QuotientWeylModule@\texttt{QuotientWeylModule}}
\label{QuotientWeylModule}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A quotient Weyl module



 Here \mbox{\texttt{\mdseries\slshape V}} is an existing Weyl module and \mbox{\texttt{\mdseries\slshape list}} is a list of basis vectors spanning a submodule of \mbox{\texttt{\mdseries\slshape V}}. Usually one gets such a basis by running SubWeylModule (see Section \ref{sec:submodules} below). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2,[2,2],"B",2);|
  <Type B2 Weyl module of highest weight [ 2, 2 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@m:= MaximalVectors(V);|
  [ 1*v0, y1*v0, y2*v0, y1*y2*v0+y3*v0, y2*y3*v0, y1*y2*y3*v0, y1*y2*y3*y4*v0 ]
  !gapprompt@gap>| !gapinput@sub:=SubWeylModule(V, m[7]);|
  [ y1*y2*y3*y4*v0 ]
  !gapprompt@gap>| !gapinput@Q:= QuotientWeylModule(V, sub);|
  <Quotient of Type B2 Weyl module of highest weight [ 2, 2 ] at prime p = 2>
\end{Verbatim}
 In the above example, we first created a Weyl module, then computed its
maximal vectors. The last maximal vector generates a one dimensional submodule
(a copy of the trivial module) and we formed the corresponding quotient Weyl
module. }

 There is also a category of quotient Weyl modules. 

\subsection{\textcolor{Chapter }{IsQuotientWeylModule}}
\logpage{[ 1, 2, 2 ]}\nobreak
\hyperdef{L}{X85565F29822787B3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsQuotientWeylModule({\mdseries\slshape Q})\index{IsQuotientWeylModule@\texttt{IsQuotientWeylModule}}
\label{IsQuotientWeylModule}
}\hfill{\scriptsize (property)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} or \texttt{false}



 This function returns \texttt{true} iff \mbox{\texttt{\mdseries\slshape Q}} is a quotient Weyl module 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsQuotientWeylModule(Q);|
  true
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Basis, dimension, and other miscellaneous commands}}\label{sec:basis-etc}
\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7DB0F0387FD8A3D1}{}
{
  Let \mbox{\texttt{\mdseries\slshape V}} be a Weyl module or a quotient Weyl module. The following commands are
available. 

\subsection{\textcolor{Chapter }{TheLieAlgebra}}
\logpage{[ 1, 3, 1 ]}\nobreak
\hyperdef{L}{X8472B03E8370745D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TheLieAlgebra({\mdseries\slshape V})\index{TheLieAlgebra@\texttt{TheLieAlgebra}}
\label{TheLieAlgebra}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BasisVecs({\mdseries\slshape V})\index{BasisVecs@\texttt{BasisVecs}}
\label{BasisVecs}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Dim({\mdseries\slshape V})\index{Dim@\texttt{Dim}}
\label{Dim}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Generator({\mdseries\slshape V})\index{Generator@\texttt{Generator}}
\label{Generator}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TheCharacteristic({\mdseries\slshape V})\index{TheCharacteristic@\texttt{TheCharacteristic}}
\label{TheCharacteristic}
}\hfill{\scriptsize (function)}}\\


 These commands return the underlying Lie algebra associated to \mbox{\texttt{\mdseries\slshape V}}, a basis (of weight vectors) for \mbox{\texttt{\mdseries\slshape V}}, the dimension of \mbox{\texttt{\mdseries\slshape V}}, the standard generator of \mbox{\texttt{\mdseries\slshape V}}, and the characteristic of the underlying field, respectively. In case \mbox{\texttt{\mdseries\slshape V}} is a quotient Weyl module, BasisVecs returns a complete set of linearly
independent coset representatives for the quotient. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2, [1,0], "G", 2);|
  <Type G2 Weyl module of highest weight [ 1, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@TheLieAlgebra(V);|
  <Lie algebra of dimension 14 over Rationals>
  !gapprompt@gap>| !gapinput@b:= BasisVecs(V);|
  [ 1*v0, y1*v0, y3*v0, y4*v0, y5*v0, y6*v0, y1*y6*v0 ]
  !gapprompt@gap>| !gapinput@Dim(V);|
  7
  !gapprompt@gap>| !gapinput@g:= Generator(V);|
  1*v0
  !gapprompt@gap>| !gapinput@TheCharacteristic(V);|
  2
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ActOn}}
\logpage{[ 1, 3, 2 ]}\nobreak
\hyperdef{L}{X7EA043B481E8841B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ActOn({\mdseries\slshape V, u, v})\index{ActOn@\texttt{ActOn}}
\label{ActOn}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A vector in \mbox{\texttt{\mdseries\slshape V}}



 ActOn returns the result of acting by a hyperalgebra element \mbox{\texttt{\mdseries\slshape u}} on a vector \mbox{\texttt{\mdseries\slshape v}}. Here \mbox{\texttt{\mdseries\slshape v}} must be an element of \mbox{\texttt{\mdseries\slshape V}}, where \mbox{\texttt{\mdseries\slshape V}} is a Weyl module or a quotient Weyl module. 

 For example, with \mbox{\texttt{\mdseries\slshape V}} as defined above in the preceding example, we have 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= TheLieAlgebra(V);|
  <Lie algebra of dimension 14 over Rationals>
  !gapprompt@gap>| !gapinput@b:= BasisVecs(V);|
  [ 1*v0, y1*v0, y3*v0, y4*v0, y5*v0, y6*v0, y1*y6*v0 ]
  !gapprompt@gap>| !gapinput@g:= LatticeGeneratorsInUEA(L);|
  [ y1, y2, y3, y4, y5, y6, x1, x2, x3, x4, x5, x6, ( h13/1 ), ( h14/1 ) ]
  !gapprompt@gap>| !gapinput@ActOn(V, g[1]^2 + g[7], b[1]);|
  0*v0
  !gapprompt@gap>| !gapinput@ActOn(V, g[1]*g[6], b[1]); |
  y1*y6*v0
\end{Verbatim}
 Note that the command LatticeGeneratorsInUEA is a pre-existing \textsf{GAP} command; see the chapter on Lie algebras in the \textsf{GAP} reference manual for further details. For our purposes, these elements are
regarded as standard generators of the hyperalgebra. }

 }

 
\section{\textcolor{Chapter }{Weight of a vector; weights of a list of vectors}}\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X840F07F57A1D0709}{}
{
 One often wants to know the weight of a given vector in a Weyl module or a
quotient Weyl module. Of course, the vector has to be a weight vector. 

\subsection{\textcolor{Chapter }{Weight}}
\logpage{[ 1, 4, 1 ]}\nobreak
\hyperdef{L}{X786C659C83E249A1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Weight({\mdseries\slshape v})\index{Weight@\texttt{Weight}}
\label{Weight}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list of integers



 The return value is a list representing the weight of the given weight vector \mbox{\texttt{\mdseries\slshape v}}. }

 Another common situation is that one has a list \mbox{\texttt{\mdseries\slshape lst}} of weight vectors (maybe a basis or a list of maximal vectors, or a basis of a
submodule) and one wants to know the weight of each vector in the list. 

\subsection{\textcolor{Chapter }{List}}
\logpage{[ 1, 4, 2 ]}\nobreak
\hyperdef{L}{X7EBA57FC7CCF8449}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{List({\mdseries\slshape lst, Weight})\index{List@\texttt{List}}
\label{List}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list of weights



 This function (a built-in \textsf{GAP} function) maps the Weight function onto each element of the given list \mbox{\texttt{\mdseries\slshape lst}} in turn, making a list of the results. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2, [2,0], "A", 2);|
  <Type A2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@b:= BasisVecs(V);|
  [ 1*v0, y1*v0, y3*v0, y1^(2)*v0, y1*y3*v0, y3^(2)*v0 ]
  !gapprompt@gap>| !gapinput@List(b, Weight);|
  [ [ 2, 0 ], [ 0, 1 ], [ 1, -1 ], [ -2, 2 ], [ -1, 0 ], [ 0, -2 ] ]
  !gapprompt@gap>| !gapinput@Weight( b[2] );|
  [ 0, 1 ]
  !gapprompt@gap>| !gapinput@m:= MaximalVectors(V);|
  [ 1*v0, y1*v0 ]
  !gapprompt@gap>| !gapinput@List(m, Weight);|
  [ [ 2, 0 ], [ 0, 1 ] ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Structure of Weyl modules}}\logpage{[ 1, 5, 0 ]}
\hyperdef{L}{X828B7C387A3461C6}{}
{
 One of the most useful commands is 

\subsection{\textcolor{Chapter }{SubmoduleStructure}}
\logpage{[ 1, 5, 1 ]}\nobreak
\hyperdef{L}{X8051037D8125EABB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SubmoduleStructure({\mdseries\slshape V})\index{SubmoduleStructure@\texttt{SubmoduleStructure}}
\label{SubmoduleStructure}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
various data structures



 This function returns a complete list of primitive vectors in a Weyl module \mbox{\texttt{\mdseries\slshape V}}, and along the way prints out an analysis of the submodule lattice structure
of \mbox{\texttt{\mdseries\slshape V}}. WARNING: If the dimension of \mbox{\texttt{\mdseries\slshape V}} is large this can take a very long time. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(3, [3,3], "A", 2);|
  <Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
  !gapprompt@gap>| !gapinput@v:= SubmoduleStructure(V);|
  Level 1
  -maximal vector v1 = y1*y2*y3*v0+y1^(2)*y2^(2)*v0 of weight [ 1, 1 ]
  Level 2
  -maximal vector v2 = y1^(2)*y2*v0 of weight [ 0, 3 ]
  -maximal vector v3 = -1*y1*y2^(2)*v0+y2*y3*v0 of weight [ 3, 0 ]
  -primitive vector v4 = y1*y2*y3^(2)*v0 of weight [ 0, 0 ]
  Level 3
  -maximal vector v5 = y1*v0 of weight [ 1, 4 ]
  -maximal vector v6 = y2*v0 of weight [ 4, 1 ]
  Level 4
  -primitive vector v7 = y1^(3)*y2^(3)*v0+y3^(3)*v0 of weight [ 0, 0 ]
  Level 5
  -maximal vector v8 = 1*v0 of weight [ 3, 3 ]
  The submodule <v1> contains v1 
  The submodule <v2> contains v1 v2 
  The submodule <v3> contains v1 v3 
  The submodule <v4> contains v1 v4 
  The submodule <v5> contains v1 v2 v3 v4 v5 
  The submodule <v6> contains v1 v2 v3 v4 v6 
  The submodule <v7> contains v1 v2 v3 v4 v5 v6 v7 
  The submodule <v8> contains v1 v2 v3 v4 v5 v6 v7 v8 
  [ y1*y2*y3*v0+y1^(2)*y2^(2)*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
    y1*y2*y3^(2)*v0, y1*v0, y2*v0, y1^(3)*y2^(3)*v0+y3^(3)*v0, 1*v0 ]
\end{Verbatim}
 This shows that \mbox{\texttt{\mdseries\slshape V}} has eight primitive vectors, six of which are maximal. The submodule generated
by each primitive vector is shown. The levels are the subquotient layers of
the socle series of \mbox{\texttt{\mdseries\slshape V}}, so this Weyl module has a simple socle of highest weight [1,1], there are
two simple composition factors of highest weight [0,3] and [3,0] extending the
socle, and so on. This example is treated in \cite{BDM}, where one can also find a diagram depicting the structure. }

 

\subsection{\textcolor{Chapter }{SocleWeyl}}
\logpage{[ 1, 5, 2 ]}\nobreak
\hyperdef{L}{X79C52EB184D3B8D7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SocleWeyl({\mdseries\slshape V})\index{SocleWeyl@\texttt{SocleWeyl}}
\label{SocleWeyl}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list



 This function returns a list of maximal vectors of the Weyl module \mbox{\texttt{\mdseries\slshape V}} that generate the socle of \mbox{\texttt{\mdseries\slshape V}}. Note that \mbox{\texttt{\mdseries\slshape V}} can also be a quotient Weyl module. 

 For example, with \mbox{\texttt{\mdseries\slshape V}} as above, we have: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SocleWeyl(V);|
  [ y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ExtWeyl}}
\logpage{[ 1, 5, 3 ]}\nobreak
\hyperdef{L}{X79B412037E52648D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ExtWeyl({\mdseries\slshape V, lst})\index{ExtWeyl@\texttt{ExtWeyl}}
\label{ExtWeyl}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list



 This function returns a list of maximal vectors generating the socle of the
quotient $V/S$ where $S$ is the submodule of \mbox{\texttt{\mdseries\slshape V}} generated by the vectors in the given list \mbox{\texttt{\mdseries\slshape lst}}. 

 For example, with \mbox{\texttt{\mdseries\slshape V}} as above, we have: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@soc:= SocleWeyl(V);|
  [ y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
  !gapprompt@gap>| !gapinput@ExtWeyl(V, soc);|
  [ y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, y1*y2*y3^(2)*v0 ]
\end{Verbatim}
 Maximal vectors generating extensions are only determined modulo $S$. In some cases, the maximal vectors returned by \texttt{ExtWeyl} are not the same as the maximal vectors returned by \texttt{SocleWeyl(\mbox{\texttt{\mdseries\slshape V}}/\mbox{\texttt{\mdseries\slshape S}})}. In order to properly detect the splitting of some extension groups, the \texttt{ExtWeyl} function may in some cases replace a maximal vector by a different choice of
representative. For example, the Weyl module of highest weight [2,0] in
characteristic 2 for Type $G_2$ exhibits such a difference: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2,[2,0],"G",2);|
  <Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@S:= SocleWeyl(V);|
  [ y1*v0, y4*v0 ]
  !gapprompt@gap>| !gapinput@e:= ExtWeyl(V,S);|
  [ y1*y6*v0+y3*y5*v0+y4^(2)*v0 ]
  !gapprompt@gap>| !gapinput@SocleWeyl( QuotientWeylModule(V,SubWeylModule(V,S)) );|
  [ y4^(2)*v0 ]
\end{Verbatim}
 In this case, the vector $y_1 y_6 v_0+y_3y_5v_0+y_4^{(2)}v_0$ is a better choice of generator than $y_4^{(2)}v_0$. Both choices are equivalent module the submodule generated by the socle, but
the first choice reveals that only one of the socle factors is extended, as
one sees by running \texttt{SubmoduleStructure} on this module. (I am indebted to Yutaka Yoshii for finding this example and
pointing out some bugs in an earlier version of the \textsf{GAP} code.) }

 

\subsection{\textcolor{Chapter }{MaximalSubmodule}}
\logpage{[ 1, 5, 4 ]}\nobreak
\hyperdef{L}{X79D8492F7B32876C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MaximalSubmodule({\mdseries\slshape V})\index{MaximalSubmodule@\texttt{MaximalSubmodule}}
\label{MaximalSubmodule}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a list



 \texttt{MaximalSubmodule} returns a basis of weight vectors for the (unique) maximal submodule of the
given Weyl module \mbox{\texttt{\mdseries\slshape V}}. The corresponding quotient is irreducible, of the same highest weight as \mbox{\texttt{\mdseries\slshape V}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2, [4,0], "A", 2); |
  UNKNOWNEntity(ly)Type A2 Weyl module of highest weight [ 4, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@Dim(V);                          |
  15
  !gapprompt@gap>| !gapinput@max:= MaximalSubmodule(V);|
  [ y1*v0, y3*v0, y1*y3*v0, y1^(3)*v0, y1*y3^(2)*v0, y1^(2)*y3*v0, y3^(3)*v0, 
    y1^(3)*y3*v0, y1*y3^(3)*v0, y1^(2)*v0, y3^(2)*v0, y1^(2)*y3^(2)*v0 ]
  !gapprompt@gap>| !gapinput@Length(max);|
  12
  !gapprompt@gap>| !gapinput@Q:= QuotientWeylModule(V, max);|
  <Quotient of Type A2 Weyl module of highest weight [ 4, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@b:= BasisVecs(Q);|
  [ 1*v0, y1^(4)*v0, y3^(4)*v0 ]
  !gapprompt@gap>| !gapinput@List(b, Weight);|
  [ [ 4, 0 ], [ -4, 4 ], [ 0, -4 ] ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Maximal and primitive vectors; homomorphisms between Weyl modules}}\label{sec:maxvec}
\logpage{[ 1, 6, 0 ]}
\hyperdef{L}{X7BEC97387E9AAB22}{}
{
 A \emph{maximal vector} is by definition a non-zero vector killed by the action of the unipotent
radical of the positive Borel subgroup; see \cite{Jantzen} for further details. 

\subsection{\textcolor{Chapter }{MaximalVectors}}
\logpage{[ 1, 6, 1 ]}\nobreak
\hyperdef{L}{X7E2F4CF283259D48}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MaximalVectors({\mdseries\slshape V})\index{MaximalVectors@\texttt{MaximalVectors}}
\label{MaximalVectors}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MaximalVectors({\mdseries\slshape V, lambda})\index{MaximalVectors@\texttt{MaximalVectors}}
\label{MaximalVectors}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 Suppose that \mbox{\texttt{\mdseries\slshape V}} is a Weyl module or a quotient Weyl module. These commands respectively return
a list of linearly independent vectors in \mbox{\texttt{\mdseries\slshape V}} spanning the subspace of all maximal vectors of \mbox{\texttt{\mdseries\slshape V}}, or a list of linearly independent vectors spanning the subspace of maximal
vectors of the given weight space of weight \mbox{\texttt{\mdseries\slshape lambda}}. (Note that linear combinations of maximal vectors are again maximal.) 

 In case \mbox{\texttt{\mdseries\slshape V}} is a Weyl module, each maximal vector of \mbox{\texttt{\mdseries\slshape V}} corresponds to a nontrivial homomorphism from the Weyl module of that highest
weight into \mbox{\texttt{\mdseries\slshape V}}. Hence the above commands can be used to determine the space \texttt{Hom(\mbox{\texttt{\mdseries\slshape W}}, \mbox{\texttt{\mdseries\slshape V}})} for two given Weyl modules \mbox{\texttt{\mdseries\slshape W}}, \mbox{\texttt{\mdseries\slshape V}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2, [2,2,2], "A", 3);|
  <Type A3 Weyl module of highest weight [ 2, 2, 2 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@m:= MaximalVectors(V);             |
  [ 1*v0, y1*v0, y2*v0, y3*v0, y1*y3*v0, y1*y2*y3*v0+y3*y4*v0+y6*v0, 
    y1*y2*y5*v0+y2*y3*y4*v0+y4*y5*v0, y1*y2*y4*v0, y2*y3*y5*v0, 
    y1*y2*y3*y4*v0+y1*y4*y5*v0, y1*y2*y3*y5*v0, y1*y2*y3*y4*y5*y6*v0 ]
  !gapprompt@gap>| !gapinput@m:= MaximalVectors(V, [0,3,2]);   |
  [ y1*v0 ]
\end{Verbatim}
 Here are two examples where the space of maximal vectors for a specified
weight has dimension strictly greater than 1. As mentioned at the beginning of
the chapter, such examples generate a warning message (which is safe to ignore
in the two cases given below). 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>B @gapinput|V:= WeylModule(2, [0,1,0,0], "D", 4); B
  <Type D4 Weyl module of highest weight [ 0, 1, 0, 0 ] at prime p = 2>
  @gapprompt|gap>B @gapinput|m:= MaximalVectors(V);B
  ********************************************************
  ** WARNING! Dimension > 1 detected
  ** in maximal vecs of weight [ 0, 0, 0, 0 ]
  ** in Weyl module of highest weight
  ** [ 0, 1, 0, 0 ]
  ********************************************************
  [ 1*v0, y5*y10*v0+y6*y9*v0, y2*y11*v0+y5*y10*v0+y12*v0 ]
  @gapprompt|gap>B @gapinput|List(m, Weight);B
  [ [ 0, 1, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ]
  @gapprompt|gap>B @gapinput|V:= WeylModule(2, [0,1,0,0,0,0], "D", 6);B
  <Type D6 Weyl module of highest weight [ 0, 1, 0, 0, 0, 0 ] at prime p = 2>
  @gapprompt|gap>B @gapinput|m:= MaximalVectors(V);                   B
  ********************************************************
  ** WARNING! Dimension > 1 detected
  ** in maximal vecs of weight [ 0, 0, 0, 0, 0, 0 ]
  ** in Weyl module of highest weight
  ** [ 0, 1, 0, 0, 0, 0 ]
  ********************************************************
  [ 1*v0, y7*y28*v0+y8*y27*v0+y13*y25*v0+y18*y22*v0, y2*y29*v0+y7*y28*v0+y30*v0 
   ]
  @gapprompt|gap>B @gapinput|List(m, Weight);                         B
  [ [ 0, 1, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0 ] ]
\end{Verbatim}
 }

 Given a weight vector \mbox{\texttt{\mdseries\slshape v}} in a Weyl module, or quotient Weyl module, one can test whether or not the
vector \mbox{\texttt{\mdseries\slshape v}} is maximal. 

\subsection{\textcolor{Chapter }{IsMaximalVector}}
\logpage{[ 1, 6, 2 ]}\nobreak
\hyperdef{L}{X85751A937E3FE648}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsMaximalVector({\mdseries\slshape V, v})\index{IsMaximalVector@\texttt{IsMaximalVector}}
\label{IsMaximalVector}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsMaximalVector({\mdseries\slshape V, lst, v})\index{IsMaximalVector@\texttt{IsMaximalVector}}
\label{IsMaximalVector}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 In the second form \mbox{\texttt{\mdseries\slshape lst}} must be a basis of weight vectors for a submodule of \mbox{\texttt{\mdseries\slshape V}}. The first form of the command returns \texttt{true} iff \mbox{\texttt{\mdseries\slshape v}} is maximal in \mbox{\texttt{\mdseries\slshape V}}; the second form returns \texttt{true} iff the image of \mbox{\texttt{\mdseries\slshape v}} is maximal in the quotient \mbox{\texttt{\mdseries\slshape V}}/\mbox{\texttt{\mdseries\slshape S}} where \mbox{\texttt{\mdseries\slshape S}} is the submodule spanned by \mbox{\texttt{\mdseries\slshape lst}}. }

 If \mbox{\texttt{\mdseries\slshape V}} is a Weyl module, a \emph{primitive vector} in \mbox{\texttt{\mdseries\slshape V}} is a vector whose image in some sub-quotient is maximal (see \cite{Xi}). Maximal vectors are always primitive, by definition. The (independent)
primitive vectors are in bijective correspondence with the composition factors
of \mbox{\texttt{\mdseries\slshape V}}. 

 If \mbox{\texttt{\mdseries\slshape V}} is a Weyl module, the command 

\subsection{\textcolor{Chapter }{PrimitiveVectors}}
\logpage{[ 1, 6, 3 ]}\nobreak
\hyperdef{L}{X7CB5F6C57BE6D4EF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PrimitiveVectors({\mdseries\slshape V})\index{PrimitiveVectors@\texttt{PrimitiveVectors}}
\label{PrimitiveVectors}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 This function returns a list of the primitive vectors of \mbox{\texttt{\mdseries\slshape V}}. This is the same list returned by \texttt{SubmoduleStructure} but it should execute faster since it does not bother about computing
structure. For example: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(3, [3,3], "A", 2);|
  <Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
  !gapprompt@gap>| !gapinput@p:= PrimitiveVectors(V);|
  [ y1*y2*y3*v0+y1^(2)*y2^(2)*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
    y1*y2*y3^(2)*v0, y1*v0, y2*v0, y1^(3)*y2^(3)*v0+y3^(3)*v0, 1*v0 ]
\end{Verbatim}
 WARNING: If the dimension of \mbox{\texttt{\mdseries\slshape V}} is large, this command can take a very long time to execute. }

 }

 
\section{\textcolor{Chapter }{Submodules}}\label{sec:submodules}
\logpage{[ 1, 7, 0 ]}
\hyperdef{L}{X7934FAE97B6D2AD8}{}
{
 Given a vector \mbox{\texttt{\mdseries\slshape v}} or a list \mbox{\texttt{\mdseries\slshape lst}} of vectors, in a given Weyl module or quotient Weyl module, \mbox{\texttt{\mdseries\slshape V}}, one obtains a basis of weight vectors for the submodule of \mbox{\texttt{\mdseries\slshape V}} generated by \mbox{\texttt{\mdseries\slshape v}} or \mbox{\texttt{\mdseries\slshape lst}} by the appropriate command listed below. 

\subsection{\textcolor{Chapter }{SubWeylModule}}
\logpage{[ 1, 7, 1 ]}\nobreak
\hyperdef{L}{X87BB881B83E8678D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SubWeylModule({\mdseries\slshape V, v})\index{SubWeylModule@\texttt{SubWeylModule}}
\label{SubWeylModule}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SubWeylModule({\mdseries\slshape V, lst})\index{SubWeylModule@\texttt{SubWeylModule}}
\label{SubWeylModule}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 These functions return a list of linearly independent weight vectors spanning
the submodule generated by either the given vector \mbox{\texttt{\mdseries\slshape v}} or the given list \mbox{\texttt{\mdseries\slshape lst}}. WARNING: This can take a very long time if the dimension of \mbox{\texttt{\mdseries\slshape V}} is large. 

 Here is an example, in which we find a submodule and compute the corresponding
quotient of the Weyl module: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2, [8,0], "A", 2);|
  <Type A2 Weyl module of highest weight [ 8, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@m:= MaximalVectors(V);           |
  [ 1*v0, y1*v0, y1^(3)*y3^(2)*v0 ]
  !gapprompt@gap>| !gapinput@List(m, Weight);                 |
  [ [ 8, 0 ], [ 6, 1 ], [ 0, 1 ] ]
  !gapprompt@gap>| !gapinput@s:= SubWeylModule(V, m[2]);|
  [ y1*v0, y3*v0, y1*y3*v0, y1^(3)*v0, y1*y3^(2)*v0, y1^(5)*v0, y1*y3^(4)*v0, 
    y1^(2)*y3*v0, y3^(3)*v0, y1^(4)*y3*v0, y3^(5)*v0, y1^(3)*y3*v0, 
    y1*y3^(3)*v0, y1^(5)*y3*v0, y1*y3^(5)*v0, y1^(3)*y3^(2)*v0, y1^(7)*v0, 
    y1^(3)*y3^(4)*v0, y1^(5)*y3^(2)*v0, y1*y3^(6)*v0, y1^(2)*y3^(3)*v0, 
    y1^(6)*y3*v0, y1^(2)*y3^(5)*v0, y1^(4)*y3^(3)*v0, y3^(7)*v0, 
    y1^(3)*y3^(3)*v0, y1^(7)*y3*v0, y1^(3)*y3^(5)*v0, y1^(5)*y3^(3)*v0, 
    y1*y3^(7)*v0 ]
  !gapprompt@gap>| !gapinput@Q:= QuotientWeylModule(V, s);|
  <Quotient of Type A2 Weyl module of highest weight [ 8, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@BasisVecs(Q);|
  [ 1*v0, y1^(2)*v0, y3^(2)*v0, y1^(4)*v0, y1^(2)*y3^(2)*v0, y1^(6)*v0, 
    y3^(4)*v0, y1^(4)*y3^(2)*v0, y1^(8)*v0, y1^(2)*y3^(4)*v0, y1^(6)*y3^(2)*v0, 
    y3^(6)*v0, y1^(4)*y3^(4)*v0, y1^(2)*y3^(6)*v0, y3^(8)*v0 ]
  !gapprompt@gap>| !gapinput@Dim(Q);|
  15
\end{Verbatim}
 One can also construct sub-quotients (continuing the preceding computation): 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@mm:= MaximalVectors(Q);|
  [ 1*v0, y1^(2)*v0 ]
  !gapprompt@gap>| !gapinput@subq:= SubWeylModule(Q, mm[2]);|
  [ y1^(2)*v0, y3^(2)*v0, y1^(2)*y3^(2)*v0, y1^(6)*v0, y1^(2)*y3^(4)*v0, 
    y1^(4)*y3^(2)*v0, y3^(6)*v0, y1^(6)*y3^(2)*v0, y1^(2)*y3^(6)*v0 ]
  !gapprompt@gap>| !gapinput@List(subq, Weight);|
  [ [ 4, 2 ], [ 6, -2 ], [ 2, 0 ], [ -4, 6 ], [ 0, -2 ], [ -2, 2 ], [ 2, -6 ], 
    [ -6, 4 ], [ -2, -4 ] ]
\end{Verbatim}
 Here, we have constructed a basis of weight vectors for the simple socle of
the quotient \mbox{\texttt{\mdseries\slshape Q}}. }

 

\subsection{\textcolor{Chapter }{IsWithin}}
\logpage{[ 1, 7, 2 ]}\nobreak
\hyperdef{L}{X796F6BF77AE2D92E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsWithin({\mdseries\slshape V, lst, v})\index{IsWithin@\texttt{IsWithin}}
\label{IsWithin}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 Let \mbox{\texttt{\mdseries\slshape V}} be a Weyl module or a quotient Weyl module. Given a list \mbox{\texttt{\mdseries\slshape lst}} of weight vectors forming a basis for a submodule, and a vector \mbox{\texttt{\mdseries\slshape v}}, the above command returns \texttt{true} iff the given vector \mbox{\texttt{\mdseries\slshape v}} lies within the submodule given by the basis \mbox{\texttt{\mdseries\slshape lst}}. }

 }

 
\section{\textcolor{Chapter }{Weights and weight spaces}}\logpage{[ 1, 8, 0 ]}
\hyperdef{L}{X7AED4BBA83011A1F}{}
{
 If \mbox{\texttt{\mdseries\slshape V}} is a Weyl module or a quotient Weyl module, the following commands are
available. 

\subsection{\textcolor{Chapter }{Weights}}
\logpage{[ 1, 8, 1 ]}\nobreak
\hyperdef{L}{X82C5F58D8788C097}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Weights({\mdseries\slshape V})\index{Weights@\texttt{Weights}}
\label{Weights}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DominantWeights({\mdseries\slshape V})\index{DominantWeights@\texttt{DominantWeights}}
\label{DominantWeights}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WeightSpaces({\mdseries\slshape V})\index{WeightSpaces@\texttt{WeightSpaces}}
\label{WeightSpaces}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DominantWeightSpaces({\mdseries\slshape V})\index{DominantWeightSpaces@\texttt{DominantWeightSpaces}}
\label{DominantWeightSpaces}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WeightSpace({\mdseries\slshape V, lambda})\index{WeightSpace@\texttt{WeightSpace}}
\label{WeightSpace}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 \texttt{Weights} returns a list of the weights of \mbox{\texttt{\mdseries\slshape V}}, without multiplicities; \texttt{DominantWeights} returns a list of the dominant weights of \mbox{\texttt{\mdseries\slshape V}}, again without multiplicities. 

 \texttt{WeightSpaces} returns a list consisting of each weight followed by a basis of the
corresponding weight space; \texttt{DominantWeightSpaces} returns just the sublist containing the dominant weights and the corresponding
weight spaces. 

 Finally, \texttt{WeightSpace} returns a basis of the particular weight space given by the specified weight \mbox{\texttt{\mdseries\slshape lambda}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2, [1,0,0], "A", 3);|
  <Type A3 Weyl module of highest weight [ 1, 0, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@Weights(V);|
  [ [ 1, 0, 0 ], [ -1, 1, 0 ], [ 0, -1, 1 ], [ 0, 0, -1 ] ]
  !gapprompt@gap>| !gapinput@DominantWeights(V);|
  [ [ 1, 0, 0 ] ]
  !gapprompt@gap>| !gapinput@WeightSpaces(V);|
  [ [ 1, 0, 0 ], [ 1*v0 ], [ -1, 1, 0 ], [ y1*v0 ], [ 0, -1, 1 ], [ y4*v0 ], 
    [ 0, 0, -1 ], [ y6*v0 ] ]
  !gapprompt@gap>| !gapinput@DominantWeightSpaces(V);|
  [ [ 1, 0, 0 ], [ 1*v0 ] ]
  !gapprompt@gap>| !gapinput@WeightSpace(V, [-1,1,0]);|
  [ y1*v0 ]
  !gapprompt@gap>| !gapinput@WeightSpace(V, [0,1,0]); |
  fail
\end{Verbatim}
 The last command prints \texttt{fail} because there are no weight vectors of weight [0,1,0] in the indicated Weyl
module. }

 }

 }

 
\chapter{\textcolor{Chapter }{Characters and decomposition numbers}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7C2B4D9A846DF9F0}{}
{
 (Formal) characters can be computed for Weyl modules and simple modules. In
the latter case, this is done recursively using Steinberg's tensor product
theorem; the characters of the simple modules of restricted highest weight are
obtained by first computing the maximal submodule and then forming the
corresponding quotient. 
\section{\textcolor{Chapter }{Characters}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7CCB304878D99999}{}
{
 We now discuss the functions available for computing characters. 

\subsection{\textcolor{Chapter }{Character}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X7BF731DC84FF733A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Character({\mdseries\slshape V})\index{Character@\texttt{Character}}
\label{Character}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 Suppose that \mbox{\texttt{\mdseries\slshape V}} is a given Weyl module or quotient Weyl module. This function returns the
formal character of \mbox{\texttt{\mdseries\slshape V}}, in the form of a list of weights and multiplicities (the multiplicity of
each weight follows the weight in the list). For example, 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(3, [3,0], "A", 2);|
  <Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
  !gapprompt@gap>| !gapinput@Character(V);|
  [ [ 3, 0 ], 1, [ 1, 1 ], 1, [ 2, -1 ], 1, [ -1, 2 ], 1, [ 0, 0 ], 1, 
    [ -3, 3 ], 1, [ 1, -2 ], 1, [ -2, 1 ], 1, [ -1, -1 ], 1, [ 0, -3 ], 1 ]
  !gapprompt@gap>| !gapinput@S:= MaximalSubmodule(V);|
  [ y1*v0, 2*y1^(2)*v0, 2*y3*v0, y1*y3*v0, 2*y1^(2)*y3*v0, y3^(2)*v0, 
    2*y1*y3^(2)*v0 ]
  !gapprompt@gap>| !gapinput@Character( QuotientWeylModule(V, S) );|
  [ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
\end{Verbatim}
 Of course, characters of Weyl modules are independent of the characteristic. }

 

\subsection{\textcolor{Chapter }{SimpleCharacter}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X871B3F6E8718C28A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SimpleCharacter({\mdseries\slshape p, wt, t, r})\index{SimpleCharacter@\texttt{SimpleCharacter}}
\label{SimpleCharacter}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SimpleCharacter({\mdseries\slshape V, wt})\index{SimpleCharacter@\texttt{SimpleCharacter}}
\label{SimpleCharacter}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 In the first form, the command \texttt{SimpleCharacter} returns the character of the simple module of highest weight \mbox{\texttt{\mdseries\slshape wt}} in characteristic \mbox{\texttt{\mdseries\slshape p}}, for the root system of Type \mbox{\texttt{\mdseries\slshape t}} and rank \mbox{\texttt{\mdseries\slshape r}}. In the second form, \mbox{\texttt{\mdseries\slshape V}} is an existing Weyl module and the data \mbox{\texttt{\mdseries\slshape p}}, \mbox{\texttt{\mdseries\slshape t}}, and \mbox{\texttt{\mdseries\slshape r}} are taken from the same data used to define \mbox{\texttt{\mdseries\slshape V}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SimpleCharacter(3, [3,0], "A", 2);    |
  [ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{Character}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X7BF731DC84FF733A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Character({\mdseries\slshape lst})\index{Character@\texttt{Character}}
\label{Character}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 This function returns the character of the submodule (of a Weyl module, or a
quotient Weyl module) spanned by the independent weight vectors in the given
list \mbox{\texttt{\mdseries\slshape lst}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2, [4,0], "A", 2);|
  <Type A2 Weyl module of highest weight [ 4, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@m:= MaximalVectors(V);|
  [ 1*v0, y1*v0 ]
  !gapprompt@gap>| !gapinput@simple:= SubWeylModule(V, m[2]);|
  [ y1*v0, y3*v0, y1*y3*v0, y1^(3)*v0, y1*y3^(2)*v0, y1^(2)*y3*v0, y3^(3)*v0, 
    y1^(3)*y3*v0, y1*y3^(3)*v0 ]
  !gapprompt@gap>| !gapinput@Character(simple);|
  [ [ 2, 1 ], 1, [ 3, -1 ], 1, [ 1, 0 ], 1, [ -2, 3 ], 1, [ 0, -1 ], 1, 
    [ -1, 1 ], 1, [ 1, -3 ], 1, [ -3, 2 ], 1, [ -1, -2 ], 1 ]
\end{Verbatim}
 In the preceding example, we obtain the character of the simple socle of the
Type $A_2$ Weyl module of highest weight [4,0], in characteristic 2. }

 

\subsection{\textcolor{Chapter }{DifferenceCharacter}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X7C0E139B7F9F7F83}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DifferenceCharacter({\mdseries\slshape c1, c2})\index{DifferenceCharacter@\texttt{DifferenceCharacter}}
\label{DifferenceCharacter}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 \texttt{DifferenceCharacter} returns the difference of two given characters, or \texttt{fail} if the difference is not another character. The arguments must be characters. 

 In the following example, we compute the character of the maximal submodule of
the Weyl module of highest weight [6,0] for Type $A_2$ in characteristic 2. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ch1:= Character( WeylModule(2, [6,0], "A", 2) ); |
  [ [ 6, 0 ], 1, [ 4, 1 ], 1, [ 5, -1 ], 1, [ 2, 2 ], 1, [ 3, 0 ], 1, [ 0, 3 ], 
    1, [ 4, -2 ], 1, [ 1, 1 ], 1, [ -2, 4 ], 1, [ 2, -1 ], 1, [ -1, 2 ], 1, 
    [ -4, 5 ], 1, [ 3, -3 ], 1, [ 0, 0 ], 1, [ -3, 3 ], 1, [ -6, 6 ], 1, 
    [ 1, -2 ], 1, [ -2, 1 ], 1, [ -5, 4 ], 1, [ 2, -4 ], 1, [ -1, -1 ], 1, 
    [ -4, 2 ], 1, [ 0, -3 ], 1, [ -3, 0 ], 1, [ 1, -5 ], 1, [ -2, -2 ], 1, 
    [ -1, -4 ], 1, [ 0, -6 ], 1 ]
  !gapprompt@gap>| !gapinput@ch2:= SimpleCharacter(2, [6,0], "A", 2);        |
  [ [ 6, 0 ], 1, [ -2, 4 ], 1, [ 2, -4 ], 1, [ 2, 2 ], 1, [ -6, 6 ], 1, 
    [ -2, -2 ], 1, [ 4, -2 ], 1, [ -4, 2 ], 1, [ 0, -6 ], 1 ]
  !gapprompt@gap>| !gapinput@d:= DifferenceCharacter(ch1, ch2);              |
  [ [ 4, 1 ], 1, [ 5, -1 ], 1, [ 3, 0 ], 1, [ 0, 3 ], 1, [ 1, 1 ], 1, 
    [ 2, -1 ], 1, [ -1, 2 ], 1, [ -4, 5 ], 1, [ 3, -3 ], 1, [ 0, 0 ], 1, 
    [ -3, 3 ], 1, [ 1, -2 ], 1, [ -2, 1 ], 1, [ -5, 4 ], 1, [ -1, -1 ], 1, 
    [ 0, -3 ], 1, [ -3, 0 ], 1, [ 1, -5 ], 1, [ -1, -4 ], 1 ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Decomposition numbers}}\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X81B34497828786F5}{}
{
 We can also compute decomposition numbers of Weyl modules. 

\subsection{\textcolor{Chapter }{DecompositionNumbers}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X837F199C864C8E6C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DecompositionNumbers({\mdseries\slshape V})\index{DecompositionNumbers@\texttt{DecompositionNumbers}}
\label{DecompositionNumbers}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 If \mbox{\texttt{\mdseries\slshape V}} is a given Weyl module, this command returns a list of highest weights of the
composition factors of \mbox{\texttt{\mdseries\slshape V}}, along with their corresponding multiplicities. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= WeylModule(2, [8,0], "A", 2);|
  <Type A2 Weyl module of highest weight [ 8, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@DecompositionNumbers(V);|
  [ [ 8, 0 ], 1, [ 6, 1 ], 1, [ 4, 2 ], 1, [ 0, 4 ], 1, [ 0, 1 ], 1 ]
  !gapprompt@gap>| !gapinput@V:= WeylModule(3, [1,1], "A", 2);|
  <Type A2 Weyl module of highest weight [ 1, 1 ] at prime p = 3>
  !gapprompt@gap>| !gapinput@DecompositionNumbers(V);         |
  [ [ 1, 1 ], 1, [ 0, 0 ], 1 ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Decomposing tensor products}}\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X7EB8D9D77D19DE97}{}
{
 One can also decompose tensor products of modules whose characters are known,
using the following functions. 

\subsection{\textcolor{Chapter }{ProductCharacter}}
\logpage{[ 2, 3, 1 ]}\nobreak
\hyperdef{L}{X7FC861037804763F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ProductCharacter({\mdseries\slshape a, b})\index{ProductCharacter@\texttt{ProductCharacter}}
\label{ProductCharacter}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DecomposeCharacter({\mdseries\slshape ch, p, t, r})\index{DecomposeCharacter@\texttt{DecomposeCharacter}}
\label{DecomposeCharacter}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 The function \texttt{ProductCharacter} returns the product of two given characters, and \texttt{DecomposeCharacter} computes the decomposition numbers of a given character \mbox{\texttt{\mdseries\slshape ch}}, relative to simple characters in characteristic \mbox{\texttt{\mdseries\slshape p}} for a given type and rank. 

 In the following example, we compute the multiplicities of simple composition
factors in the tensor square of the natural representation for the group of
Type $A_4$ in characteristic 2. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ch:= SimpleCharacter(2, [1,0,0,0], "A", 4);|
  [ [ 1, 0, 0, 0 ], 1, [ -1, 1, 0, 0 ], 1, [ 0, -1, 1, 0 ], 1, [ 0, 0, -1, 1 ], 
    1, [ 0, 0, 0, -1 ], 1 ]
  !gapprompt@gap>| !gapinput@chsquared:= ProductCharacter(ch, ch);|
  [ [ 2, 0, 0, 0 ], 1, [ 0, 1, 0, 0 ], 2, [ 1, -1, 1, 0 ], 2, [ 1, 0, -1, 1 ], 
    2, [ 1, 0, 0, -1 ], 2, [ -2, 2, 0, 0 ], 1, [ -1, 0, 1, 0 ], 2, 
    [ -1, 1, -1, 1 ], 2, [ -1, 1, 0, -1 ], 2, [ 0, -2, 2, 0 ], 1, 
    [ 0, -1, 0, 1 ], 2, [ 0, -1, 1, -1 ], 2, [ 0, 0, -2, 2 ], 1, 
    [ 0, 0, -1, 0 ], 2, [ 0, 0, 0, -2 ], 1 ]
  !gapprompt@gap>| !gapinput@DecomposeCharacter(chsquared, 2, "A", 4);|
  [ [ 2, 0, 0, 0 ], 1, [ 0, 1, 0, 0 ], 2 ]
\end{Verbatim}
 }

 }

 }

 
\chapter{\textcolor{Chapter }{Schur algebras and Symmetric Groups}}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7817A3B07E17884E}{}
{
 In principle, the decomposition numbers for the algebraic group ${\rm SL}_n$ of Type $A_{n-1}$ determine the decomposition numbers for Schur algebras, and thus determine
also the decomposiotion numbers for symmetric groups. People working with
Schur algebras and symmetric groups often prefer to use partitions to label
highest weights. Of course, it is trivial to convert between ${\rm SL}_n$ weight and partition notation. This section covers functions that perform such
conversions, and various other functions for Schur algebras and symmetric
groups. 
\section{\textcolor{Chapter }{Compositions and Weights}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X82C9B62E81E4B44F}{}
{
 A \emph{composition} of degree $r$ is a finite sequence $c = [c_1, \dots, c_n]$ of non-negative integers which sum to $r$. The number $n$ of parts of $c$ is called its \emph{length}. One may identify the set of compositions of length $n$ with the set of \emph{polynomial} weights of the algebraic group ${\rm GL}_n$. 

 Note that a composition is a partition if and only if it is a dominant weight
relative to the diagonal maximal torus in ${\rm GL}_n$. 

\subsection{\textcolor{Chapter }{CompositionToWeight}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7F5BE0C778965ED9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CompositionToWeight({\mdseries\slshape c})\index{CompositionToWeight@\texttt{CompositionToWeight}}
\label{CompositionToWeight}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WeightToComposition({\mdseries\slshape r, wt})\index{WeightToComposition@\texttt{WeightToComposition}}
\label{WeightToComposition}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 \texttt{CompositionToWeight} converts a given list \mbox{\texttt{\mdseries\slshape c}} (of length \mbox{\texttt{\mdseries\slshape n}}) into an ${\rm SL}_n$ weight, by taking successive differences in the parts of \mbox{\texttt{\mdseries\slshape c}}. This produces a list of length $n-1$. 

 \texttt{WeightToComposition} does the reverse operation, padding with zeros if necessary in order to return
a composition of degree \mbox{\texttt{\mdseries\slshape r}}. The degree must be specified since it is not uniquely determined by the
given weight. Note that degree is unique modulo \mbox{\texttt{\mdseries\slshape n}}. The length \mbox{\texttt{\mdseries\slshape n}} of the output is always one more than the length of the input. 

 As a special case, these operations take partitions to dominant weights, and
vice versa. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@wt:= CompositionToWeight( [3,3,2,1,1,0,0] );|
  [ 0, 1, 1, 0, 1, 0 ]
  !gapprompt@gap>| !gapinput@WeightToComposition(10, wt);|
  [ 3, 3, 2, 1, 1, 0, 0 ]
  !gapprompt@gap>| !gapinput@WeightToComposition(17, wt);|
  [ 4, 4, 3, 2, 2, 1, 1 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{BoundedPartitions}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X87B4FF987D56A4EF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BoundedPartitions({\mdseries\slshape n, r, s})\index{BoundedPartitions@\texttt{BoundedPartitions}}
\label{BoundedPartitions}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BoundedPartitions({\mdseries\slshape n, r})\index{BoundedPartitions@\texttt{BoundedPartitions}}
\label{BoundedPartitions}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 \texttt{BoundedPartitions(\mbox{\texttt{\mdseries\slshape n}},\mbox{\texttt{\mdseries\slshape r}},\mbox{\texttt{\mdseries\slshape s}})} returns a list of \mbox{\texttt{\mdseries\slshape n}}-part partitions of degree \mbox{\texttt{\mdseries\slshape r}}, where each part lies in the interval [0,\mbox{\texttt{\mdseries\slshape s}}]. Note that some parts of the partition may be equal to zero. 

 \texttt{BoundedPartitions(\mbox{\texttt{\mdseries\slshape n}},\mbox{\texttt{\mdseries\slshape r}})} is equivalent to \texttt{BoundedPartitions(\mbox{\texttt{\mdseries\slshape n}},\mbox{\texttt{\mdseries\slshape r}},\mbox{\texttt{\mdseries\slshape r}})}, which returns a list of all \mbox{\texttt{\mdseries\slshape n}}-part partitions of degree \mbox{\texttt{\mdseries\slshape r}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@BoundedPartitions(4,3,2);           |
  [ [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
  !gapprompt@gap>| !gapinput@BoundedPartitions(4,3,3);|
  [ [ 3, 0, 0, 0 ], [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
  !gapprompt@gap>| !gapinput@BoundedPartitions(4,3);|
  [ [ 3, 0, 0, 0 ], [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
  !gapprompt@gap>| !gapinput@BoundedPartitions(4,4,4);|
  [ [ 4, 0, 0, 0 ], [ 3, 1, 0, 0 ], [ 2, 2, 0, 0 ], [ 2, 1, 1, 0 ], 
    [ 1, 1, 1, 1 ] ]
\end{Verbatim}
 Note that running \texttt{BoundedPartitions(\mbox{\texttt{\mdseries\slshape n}},\mbox{\texttt{\mdseries\slshape n}},\mbox{\texttt{\mdseries\slshape n}})} produces a list of all partitions of \mbox{\texttt{\mdseries\slshape n}}. }

 }

 
\section{\textcolor{Chapter }{Schur Algebras}}\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X802799E57A84025C}{}
{
 

\subsection{\textcolor{Chapter }{SchurAlgebraWeylModule}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X7F659C2A83FD5ECB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SchurAlgebraWeylModule({\mdseries\slshape p, lambda})\index{SchurAlgebraWeylModule@\texttt{SchurAlgebraWeylModule}}
\label{SchurAlgebraWeylModule}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a Weyl module



 \texttt{SchurAlgebraWeylModule} returns the Weyl module of highest weight \mbox{\texttt{\mdseries\slshape wt}} in characteristic \mbox{\texttt{\mdseries\slshape p}}, regarded as a module for ${\rm GL}_n$ where \mbox{\texttt{\mdseries\slshape n}} is the length of the given partition \mbox{\texttt{\mdseries\slshape lambda}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= SchurAlgebraWeylModule(3, [2,2,1,1,0]);|
  <Schur algebra Weyl module of highest weight [ 2, 2, 1, 1, 0 ] at prime p = 3>
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{DecompositionNumbers}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X837F199C864C8E6C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DecompositionNumbers({\mdseries\slshape V})\index{DecompositionNumbers@\texttt{DecompositionNumbers}}
\label{DecompositionNumbers}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 \texttt{DecompositionNumbers} returns the decomposition numbers of a given Schur algebra Weyl module \mbox{\texttt{\mdseries\slshape V}}, using partition notation for dominant weights. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= SchurAlgebraWeylModule(3, [2,2,1,1,0]);|
  <Schur algebra Weyl module of highest weight [ 2, 2, 1, 1, 0 ] at prime p = 3>
  !gapprompt@gap>| !gapinput@DecompositionNumbers(V);|
  [ [ 2, 2, 1, 1, 0 ], 1 ]
\end{Verbatim}
 The above example shows an irreducible Weyl module for ${\rm GL}_5$. Here is a more interesting example: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= SchurAlgebraWeylModule(2, [4,2,1,1,0]);|
  <Schur algebra Weyl module of highest weight [ 4, 2, 1, 1, 0 ] at prime p = 2>
  !gapprompt@gap>| !gapinput@DecompositionNumbers(V);                   |
  [ [ 4, 2, 1, 1, 0 ], 1, [ 3, 3, 1, 1, 0 ], 1, [ 3, 2, 2, 1, 0 ], 1, 
    [ 4, 1, 1, 1, 1 ], 1, [ 2, 2, 2, 2, 0 ], 1, [ 2, 2, 2, 1, 1 ], 1 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SchurAlgebraDecompositionMatrix}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X79BFB3007DCB9CF1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SchurAlgebraDecompositionMatrix({\mdseries\slshape p, n, r})\index{SchurAlgebraDecompositionMatrix@\texttt{SchurAlgebraDecompositionMatrix}}
\label{SchurAlgebraDecompositionMatrix}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list of lists



 \texttt{SchurAlgebraDecompositionMatrix} returns the decomposition matrix for a Schur algebra $S(n,r)$ in characteristic \mbox{\texttt{\mdseries\slshape p}}. The rows and columns of the matrix are indexed by the partitions produced by \texttt{BoundedPartitions(\mbox{\texttt{\mdseries\slshape n}},\mbox{\texttt{\mdseries\slshape r}})}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SchurAlgebraDecompositionMatrix(2, 4, 5);|
  [ [ 1, 0, 1, 1, 0, 0 ], [ 0, 1, 0, 0, 0, 1 ], [ 0, 0, 1, 1, 1, 0 ], 
    [ 0, 0, 0, 1, 1, 0 ], [ 0, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ]
  !gapprompt@gap>| !gapinput@BoundedPartitions(4,5);|
  [ [ 5, 0, 0, 0 ], [ 4, 1, 0, 0 ], [ 3, 2, 0, 0 ], [ 3, 1, 1, 0 ], 
    [ 2, 2, 1, 0 ], [ 2, 1, 1, 1 ] ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Symmetric groups}}\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X7BE4F15F78127B12}{}
{
 Symmetric group decomposition numbers in positive characteristic may be
obtained from corresponding decomposition numbers for a Schur algebra Weyl
module, by means of the well known ``Schur functor''. (See for instance Chapter 6 of \cite{Green} for details.) 

 This is not a very efficient method to calculate those decomposition numbers.
People needing such numbers for large partitions should use other methods. The
approach taken here, through Schur algebras, is reasonably fast only up to
about degree 7 at present. 

\subsection{\textcolor{Chapter }{SymmetricGroupDecompositionNumbers}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X78755A2F79DE1B84}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SymmetricGroupDecompositionNumbers({\mdseries\slshape p, mu})\index{SymmetricGroupDecompositionNumbers@\texttt{SymmetricGroupDecompositionNumbers}}
\label{SymmetricGroupDecompositionNumbers}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 \texttt{SymmetricGroupDecompositionNumbers} returns a list of the decomposition numbers $[S_\mu: D_\lambda]$ for the dual Specht module $S_\mu$ labeled by a partition $\mu$, in characteristic \mbox{\texttt{\mdseries\slshape p}}. The simple modules $D_\lambda$ are labeled by \mbox{\texttt{\mdseries\slshape p}}-restricted partitions of the same degree as $\mu$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SymmetricGroupDecompositionNumbers(3, [3,2,1]);|
  [ [ 3, 2, 1 ], 1, [ 2, 2, 2 ], 1, [ 3, 1, 1, 1 ], 1, [ 2, 1, 1, 1, 1 ], 1, 
    [ 1, 1, 1, 1, 1, 1 ], 1 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SymmetricGroupDecompositionMatrix}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X833A2717839A8F36}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SymmetricGroupDecompositionMatrix({\mdseries\slshape p, n})\index{SymmetricGroupDecompositionMatrix@\texttt{SymmetricGroupDecompositionMatrix}}
\label{SymmetricGroupDecompositionMatrix}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list of lists



 \texttt{SymmetricGroupDecompositionMatrix} returns the decomposition matrix for the symmetric group on \mbox{\texttt{\mdseries\slshape n}} letters, in characteristic \mbox{\texttt{\mdseries\slshape p}}. The rows of the matrix are labeled by partitions of \mbox{\texttt{\mdseries\slshape n}} and columns are labeled by the \mbox{\texttt{\mdseries\slshape p}}-restricted partitions of \mbox{\texttt{\mdseries\slshape n}}. 

 To obtain lists of the row and column labels use the following functions. }

 

\subsection{\textcolor{Chapter }{AllPartitions}}
\logpage{[ 3, 3, 3 ]}\nobreak
\hyperdef{L}{X873D727E7E1A113A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{AllPartitions({\mdseries\slshape n})\index{AllPartitions@\texttt{AllPartitions}}
\label{AllPartitions}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{pRestrictedPartitions({\mdseries\slshape p, n})\index{pRestrictedPartitions@\texttt{pRestrictedPartitions}}
\label{pRestrictedPartitions}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 These functions respectively return a list of all partitions of \mbox{\texttt{\mdseries\slshape n}}, and a list of all \mbox{\texttt{\mdseries\slshape p}}-restricted partitions of \mbox{\texttt{\mdseries\slshape n}}. Note that trailing zeros are omitted in such partitions. (\textsf{GAP} has a built-in \texttt{Partitions} function that also gives all the partitions of \mbox{\texttt{\mdseries\slshape n}}, but the ordering is different from the ordering in \texttt{AllPartitions} above. To correctly interpret row labels in the decomposition matrix, one must
use the ordering in \texttt{AllPartitions}.) 

 For example, we compute the decomposition matrix for the symmetric group on 5
letters in characteristic 2, along with the row and column labels for the
matrix: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SymmetricGroupDecompositionMatrix(2, 5);|
  [ [ 0, 0, 1 ], [ 0, 1, 0 ], [ 1, 0, 1 ], [ 1, 0, 2 ], [ 1, 0, 1 ], 
    [ 0, 1, 0 ], [ 0, 0, 1 ] ]
  !gapprompt@gap>| !gapinput@AllPartitions(5);|
  [ [ 5 ], [ 4, 1 ], [ 3, 2 ], [ 3, 1, 1 ], [ 2, 2, 1 ], [ 2, 1, 1, 1 ], 
    [ 1, 1, 1, 1, 1 ] ]
  !gapprompt@gap>| !gapinput@pRestrictedPartitions(2,5);|
  [ [ 2, 2, 1 ], [ 2, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{The Mullineux correspondence}}\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X78EDAF2F86560B70}{}
{
 Computing symmetric group decomposition numbers by means of the Schur functor
naturally produces the decomposition numbers $[S_\mu: D_\lambda]$ for partitions $\mu$ and $p$-restricted partitions $\lambda$. Here $S^\mu$ is the dual Specht module labeled by $\mu$ and $D_\lambda$ the dual simple module labeled by $\mu$. 

 Let $\lambda'$ be the conjugate partition of a partition $\lambda$, obtained by transposing rows and columns of the corresponding Young diagram.
We have $(S^{\mu})^\ast \simeq S_\mu$ for a partition $\mu$ and $D^\lambda \otimes {\rm sgn} \simeq D_{\lambda'}$ for a $p$-regular partition $\lambda$, where $S^\mu$ is the usual Specht module and $D^\lambda$ the usual simple module, using notation in accord with \cite{James}. The notation ${\rm sgn}$ refers to the sign representation. 

 Thus it follows that $[S_\mu: D_\lambda] = [S^\mu: D^{{\rm Mull}(\lambda')}]$ if $\lambda$ is $p$-restricted. So by sending $\lambda \to {\rm Mull}(\lambda')$, one obtains the column labels for the decomposition matrix that appear in \cite{James}. 

\subsection{\textcolor{Chapter }{Mullineux}}
\logpage{[ 3, 4, 1 ]}\nobreak
\hyperdef{L}{X7BDED41984BEFB59}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Mullineux({\mdseries\slshape p, mu})\index{Mullineux@\texttt{Mullineux}}
\label{Mullineux}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 \texttt{Mullineux} returns the partition ${\rm Mull}(\mu)$ corresponding to a given $p$-regular partition $\mu$ under the Mullineux map. This means by definition that $D^\mu \otimes {\rm sgn} \simeq D^{{\rm Mull}(\mu)}$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Mullineux(3, [5,4,1,1]);|
  [ 9, 2 ]
  !gapprompt@gap>| !gapinput@Mullineux(3, [9,2]);    |
  [ 5, 4, 1, 1 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{pRegularPartitions}}
\logpage{[ 3, 4, 2 ]}\nobreak
\hyperdef{L}{X7A951CB38756FC42}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{pRegularPartitions({\mdseries\slshape p, n})\index{pRegularPartitions@\texttt{pRegularPartitions}}
\label{pRegularPartitions}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 \texttt{pRegularPartitions} returns a list of the $p$-regular partitions of \mbox{\texttt{\mdseries\slshape n}}, in bijection with the list of $p$-restricted partitions of \mbox{\texttt{\mdseries\slshape n}} produced by \texttt{pRestrictedPartitions}, using the bijection $\lambda \to {\rm Mull}(\lambda')$. Thus, to read a symmetric group decomposition matrix using $p$-regular partition notation, one uses the output of \texttt{pRegularPartitions} to index the columns of the matrix. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SymmetricGroupDecompositionMatrix(3, 5);|
  [ [ 0, 0, 1, 0, 0 ], [ 1, 0, 0, 0, 0 ], [ 1, 0, 0, 0, 1 ], [ 0, 1, 0, 0, 0 ], 
    [ 0, 0, 1, 1, 0 ], [ 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 1 ] ]
  !gapprompt@gap>| !gapinput@AllPartitions(5);                       |
  [ [ 5 ], [ 4, 1 ], [ 3, 2 ], [ 3, 1, 1 ], [ 2, 2, 1 ], [ 2, 1, 1, 1 ], 
    [ 1, 1, 1, 1, 1 ] ]
  !gapprompt@gap>| !gapinput@pRegularPartitions(3, 5);|
  [ [ 4, 1 ], [ 3, 1, 1 ], [ 5 ], [ 2, 2, 1 ], [ 3, 2 ] ]
\end{Verbatim}
 In the above example, we computed a decomposition matrix in characteristic 3
for the symmetric group on 5 letters, along with labels for its rows and
columns, using $p$-regular partitions to label the columns. If one wants instead to use $p$-restricted column labels, one needs to run: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@pRestrictedPartitions(3, 5);|
  [ [ 3, 2 ], [ 3, 1, 1 ], [ 2, 2, 1 ], [ 2, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
\end{Verbatim}
 from the preceding section, to see the correspondence. }

 }

 
\section{\textcolor{Chapter }{Miscellaneous functions for partitions}}\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X824418F6788DE833}{}
{
 Here are a few additional miscellaneous functions useful for computing with
partitions. 

\subsection{\textcolor{Chapter }{Conjugate}}
\logpage{[ 3, 5, 1 ]}\nobreak
\hyperdef{L}{X87C9E8597DDE0431}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Conjugate({\mdseries\slshape mu})\index{Conjugate@\texttt{Conjugate}}
\label{Conjugate}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a list



 \texttt{Conjugate} returns the conjugate partition $\mu'$ of its input $\mu$. The Young diagram of $\mu'$ is obtained from that of $\mu$ by transposing rows and columns. For example, 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Conjugate( [4,4,2,1] );|
  [ 4, 3, 2, 2 ]
  !gapprompt@gap>| !gapinput@Conjugate( [4,3,2,2] );|
  [ 4, 4, 2, 1 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{pRestricted}}
\logpage{[ 3, 5, 2 ]}\nobreak
\hyperdef{L}{X867CC58F7B74C723}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{pRestricted({\mdseries\slshape p, mu})\index{pRestricted@\texttt{pRestricted}}
\label{pRestricted}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{pRegular({\mdseries\slshape p, mu})\index{pRegular@\texttt{pRegular}}
\label{pRegular}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{true} or \texttt{false}



 \texttt{pRestricted} returns \texttt{true} iff the partition \mbox{\texttt{\mdseries\slshape mu}} is $p$-restricted (succesive differences $\mu_i - \mu_{i+1}$ are strictly bounded above by $p$); similarly \texttt{pRegular} returns \texttt{true} iff the partition \mbox{\texttt{\mdseries\slshape mu}} is $p$-regular (equivalently, the conjugate of \mbox{\texttt{\mdseries\slshape mu}} is $p$-restricted). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@pRestricted(3, [6,6,6,4,4,2,1,1]);|
  true
  !gapprompt@gap>| !gapinput@pRestricted(3, [6,3,1,1]);|
  false
  !gapprompt@gap>| !gapinput@pRegular(3, [8,6,5,5,3,3]);       |
  true
  !gapprompt@gap>| !gapinput@pRegular(3, [3,3,3,2,2,1,1]);|
  false
\end{Verbatim}
 }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{weyl}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
