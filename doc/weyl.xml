<?xml version="1.0" encoding="UTF-8"?>
<!--  WeylModule Package documentation  -->
<!DOCTYPE Book SYSTEM "gapdoc.dtd">

<Book Name="Weyl">

<TitlePage>
  <Title><Package>Weyl Modules</Package></Title>
  <Version>Version 2.0</Version>
  <Author>S. R. Doty
    <Email>doty@math.luc.edu</Email>
  </Author>

  <Copyright>&copyright; 2009, 2019 S. R. Doty.
  <P/>
  This package is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version. For details, see
  <URL>https://www.gnu.org/licenses/licenses.html</URL>.
  <P/>
  This software is distributed <E>as is</E> without warranty of any
  kind, either expressed or implied, including, but not limited to,
  the implied warranties of merchantability and fitness for a
  particular purpose.
  </Copyright>
</TitlePage>

<TableOfContents/>


<Body>
<Chapter><Heading>Weyl modules</Heading>

This chapter discusses the commands available for computations with
Weyl modules for a given simple simply-connected algebraic group
<M>G</M> in positive characteristic <M>p</M>. Actually the group
<M>G</M> itself never appears in any of the computations, which take
place instead using the <E>algebra of distributions</E> (also known as
the <E>hyperalgebra</E>) of <M>G</M>, taken over the prime field.  One
should refer to <Cite Key="Jantzen"/> for the definition of the
algebra of distributions, and other basic definitions and properties
related to Weyl modules.
<P/>
The algorithms are based on the method of <Cite Key="Irving"/> (see
also <Cite Key="Xi"/>) and build on the existing Lie algebra
functionality in &GAP;. In principle, one can work with arbitrary
weights for an arbitrary (simple) root system; in practice, the
functionality is limited by the size of the objects being computed. If
your Weyl module has dimension in the thousands, you may have to wait
a very long time for certain computations to finish.
<P/>
The package is possibly most useful for doing computations in
characteristic <M>p</M> where <M>p</M> is smaller than the Coxeter
number. For such small primes, the general theory offers very little
information.
<P/>
<E>Warning.</E> At the core of many of the computations is a routine
which produces a basis for the space of maximal vectors of a specified
dominant weight in a Weyl module. Usually, that space has dimension at
most 1.  Cases for which there exist two or more independent maximal
vectors of the same weight could possibly cause problems, so the code
will emit an warning message if this occurs (and then try to
continue).  Such situations are relatively rare (and interesting); the
smallest example known to the author occurs in Type <M>D_4</M> in the
Weyl module of highest weight [0,1,0,0], as pointed out on page 173 of
<Cite Key="CPS"/>. (I am grateful to Anton Cox for this reference.)
See the examples in Section <Ref Sect="sec:maxvec"/> to see the
explicit form of the warning message.

<Section Label='sec:create'> <Heading>Creating Weyl modules</Heading>

There are two functions for creating a Weyl module. 

<ManSection>
<Func Name='WeylModule' Arg='p, lambda, t, r'/>
<Func Name='WeylModule' Arg='V, lambda'/>
<Returns>A Weyl module</Returns>
<Description>
The function <C>WeylModule</C> with four arguments creates a Weyl
module over a field of characteristic <A>p</A>, of highest weight
<A>lambda</A>, for the root system of Type <A>t</A> and rank
<A>r</A>. The type should be a string of the form <Q>A</Q> through
<Q>G</Q>.
<P/>
In the second form, with two arguments, <A>V</A> is an existing Weyl
module and the new Weyl module has the same characteristic and root
system as the existing one.
<Example>
gap> V:= WeylModule(3, [3,4], "A", 2);
&lt;Type A2 Weyl module of highest weight [ 3, 4 ] at prime p = 3>
gap> W:= WeylModule(V, [3,0]);
&lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
</Example>
</Description>
</ManSection>

There is also a category of Weyl modules.

<ManSection>
<Prop Name='IsWeylModule' Arg='V'/>
<Returns> <K>true</K> or <K>false</K></Returns>
<Description>
This function returns <K>true</K> iff <A>V</A> is a Weyl module. 
<Example>
gap> IsWeylModule(W);
true
</Example>
</Description>

</ManSection>
</Section>


<Section Label='sec:quotients'>
<Heading>Creating quotients of Weyl modules</Heading>

Quotients of Weyl modules are also supported. They are created by
the following command.

<ManSection>
<Func Name='QuotientWeylModule' Arg='V, list'/>
<Returns>A quotient Weyl module</Returns>
<Description>
Here <A>V</A> is an existing Weyl module and <A>list</A> is a list of
basis vectors spanning a submodule of <A>V</A>. Usually one gets such
a basis by running SubWeylModule (see Section <Ref
Sect="sec:submodules"/> below).

<Example>
gap> V:= WeylModule(2,[2,2],"B",2);
&lt;Type B2 Weyl module of highest weight [ 2, 2 ] at prime p = 2>
gap> m:= MaximalVectors(V);
[ 1*v0, y1*v0, y2*v0, y1*y2*v0+y3*v0, y2*y3*v0, y1*y2*y3*v0, y1*y2*y3*y4*v0 ]
gap> sub:=SubWeylModule(V, m[7]);
[ y1*y2*y3*y4*v0 ]
gap> Q:= QuotientWeylModule(V, sub);
&lt;Quotient of Type B2 Weyl module of highest weight [ 2, 2 ] at prime p = 2>
</Example>

In the above example, we first created a Weyl module, then computed
its maximal vectors. The last maximal vector generates a one
dimensional submodule (a copy of the trivial module) and we formed the
corresponding quotient Weyl module.
</Description>
</ManSection>

There is also a category of quotient Weyl modules. 

<ManSection>
<Prop Name='IsQuotientWeylModule' Arg='Q'/>
<Returns> <K>true</K> or <K>false</K></Returns>
<Description>
This function returns <K>true</K> iff <A>Q</A> is a quotient Weyl module
<Example>
gap> IsQuotientWeylModule(Q);
true
</Example>
</Description>
</ManSection>
</Section>


<Section Label='sec:basis-etc'>
<Heading>Basis, dimension, and other miscellaneous commands</Heading>

Let <A>V</A> be a Weyl module or a quotient Weyl module. The following
commands are available.

<ManSection>
<Func Name='TheLieAlgebra' Arg='V'/>
<Func Name='BasisVecs' Arg='V'/>
<Func Name='Dim' Arg='V'/>
<Func Name='Generator' Arg='V'/>
<Func Name='TheCharacteristic' Arg='V'/>
<Description>
These commands return the underlying Lie algebra associated to
<A>V</A>, a basis (of weight vectors) for <A>V</A>, the dimension of
<A>V</A>, the standard generator of <A>V</A>, and the characteristic
of the underlying field, respectively. In case <A>V</A> is a quotient
Weyl module, BasisVecs returns a complete set of linearly
independent coset representatives for the quotient.

<Example>
gap> V:= WeylModule(2, [1,0], "G", 2);
&lt;Type G2 Weyl module of highest weight [ 1, 0 ] at prime p = 2>
gap> TheLieAlgebra(V);
&lt;Lie algebra of dimension 14 over Rationals>
gap> b:= BasisVecs(V);
[ 1*v0, y1*v0, y3*v0, y4*v0, y5*v0, y6*v0, y1*y6*v0 ]
gap> Dim(V);
7
gap> g:= Generator(V);
1*v0
gap> TheCharacteristic(V);
2
</Example>
</Description>
</ManSection>

<ManSection>
<Func Name='ActOn' Arg='V, u, v'/>
<Returns>A vector in <A>V</A></Returns>
<Description>
ActOn returns the result of acting by a hyperalgebra element <A>u</A>
on a vector <A>v</A>. Here <A>v</A> must be an element of <A>V</A>,
where <A>V</A> is a Weyl module or a quotient Weyl module.
<P/>
For example, with <A>V</A> as defined above in the preceding example,
we have

<Example>
gap> L:= TheLieAlgebra(V);
&lt;Lie algebra of dimension 14 over Rationals>
gap> b:= BasisVecs(V);
[ 1*v0, y1*v0, y3*v0, y4*v0, y5*v0, y6*v0, y1*y6*v0 ]
gap> g:= LatticeGeneratorsInUEA(L);
[ y1, y2, y3, y4, y5, y6, x1, x2, x3, x4, x5, x6, ( h13/1 ), ( h14/1 ) ]
gap> ActOn(V, g[1]^2 + g[7], b[1]);
0*v0
gap> ActOn(V, g[1]*g[6], b[1]); 
y1*y6*v0
</Example>

Note that the command LatticeGeneratorsInUEA is a pre-existing &GAP;
command; see the chapter on Lie algebras in the &GAP; reference manual
for further details. For our purposes, these elements are regarded as
standard generators of the hyperalgebra.
</Description>
</ManSection>
</Section>


<Section><Heading>Weight of a vector; weights of a list of vectors</Heading>

One often wants to know the weight of a given vector in a Weyl module
or a quotient Weyl module. Of course, the vector has to be a weight
vector.

<ManSection>
<Func Name='Weight' Arg='v'/>
<Returns> a list of integers</Returns>
<Description>
The return value is a list representing the weight of the given weight
vector <A>v</A>.
</Description>
</ManSection>

Another common situation is that one has a list <A>lst</A> of weight
vectors (maybe a basis or a list of maximal vectors, or a basis of a
submodule) and one wants to know the weight of each vector in the
list.

<ManSection>
<Func Name='List' Arg='lst, Weight'/>
<Returns> a list of weights</Returns>
<Description>
This function (a built-in &GAP; function) maps the Weight function
onto each element of the given list <A>lst</A> in turn, making a list
of the results.

<Example>
gap> V:= WeylModule(2, [2,0], "A", 2);
&lt;Type A2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
gap> b:= BasisVecs(V);
[ 1*v0, y1*v0, y3*v0, y1^(2)*v0, y1*y3*v0, y3^(2)*v0 ]
gap> List(b, Weight);
[ [ 2, 0 ], [ 0, 1 ], [ 1, -1 ], [ -2, 2 ], [ -1, 0 ], [ 0, -2 ] ]
gap> Weight( b[2] );
[ 0, 1 ]
gap> m:= MaximalVectors(V);
[ 1*v0, y1*v0 ]
gap> List(m, Weight);
[ [ 2, 0 ], [ 0, 1 ] ]
</Example>
</Description>
</ManSection>
</Section>


<Section><Heading>Structure of Weyl modules</Heading>

One of the most useful commands is

<ManSection>
<Func Name='SubmoduleStructure' Arg='V'/>
<Returns>various data structures</Returns>
<Description>
This function returns a complete list of primitive vectors in a Weyl
module <A>V</A>, and along the way prints out an analysis of the
submodule lattice structure of <A>V</A>. WARNING: If the dimension of
<A>V</A> is large this can take a very long time.

<Example>
gap> V:= WeylModule(3, [3,3], "A", 2);
&lt;Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> v:= SubmoduleStructure(V);
Level 1
-maximal vector v1 = y1*y2*y3*v0+y1^(2)*y2^(2)*v0 of weight [ 1, 1 ]
Level 2
-maximal vector v2 = y1^(2)*y2*v0 of weight [ 0, 3 ]
-maximal vector v3 = -1*y1*y2^(2)*v0+y2*y3*v0 of weight [ 3, 0 ]
-primitive vector v4 = y1*y2*y3^(2)*v0 of weight [ 0, 0 ]
Level 3
-maximal vector v5 = y1*v0 of weight [ 1, 4 ]
-maximal vector v6 = y2*v0 of weight [ 4, 1 ]
Level 4
-primitive vector v7 = y1^(3)*y2^(3)*v0+y3^(3)*v0 of weight [ 0, 0 ]
Level 5
-maximal vector v8 = 1*v0 of weight [ 3, 3 ]
The submodule &lt;v1> contains v1 
The submodule &lt;v2> contains v1 v2 
The submodule &lt;v3> contains v1 v3 
The submodule &lt;v4> contains v1 v4 
The submodule &lt;v5> contains v1 v2 v3 v4 v5 
The submodule &lt;v6> contains v1 v2 v3 v4 v6 
The submodule &lt;v7> contains v1 v2 v3 v4 v5 v6 v7 
The submodule &lt;v8> contains v1 v2 v3 v4 v5 v6 v7 v8 
[ y1*y2*y3*v0+y1^(2)*y2^(2)*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
  y1*y2*y3^(2)*v0, y1*v0, y2*v0, y1^(3)*y2^(3)*v0+y3^(3)*v0, 1*v0 ]
</Example>

This shows that <A>V</A> has eight primitive vectors, six of which are
maximal. The submodule generated by each primitive vector is
shown. The levels are the subquotient layers of the socle series of
<A>V</A>, so this Weyl module has a simple socle of highest weight
[1,1], there are two simple composition factors of highest weight
[0,3] and [3,0] extending the socle, and so on. This example is
treated in <Cite Key='BDM'/>, where one can also find a diagram
depicting the structure.
</Description>
</ManSection>


<ManSection>
<Func Name='SocleWeyl' Arg='V'/>
<Returns> a list</Returns>
<Description>
This function returns a list of maximal vectors of the Weyl module
<A>V</A> that generate the socle of <A>V</A>. Note that <A>V</A> can
also be a quotient Weyl module.
<P/>
For example, with <A>V</A> as above, we have:

<Example>
gap> SocleWeyl(V);
[ y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
</Example>
</Description>
</ManSection>

<ManSection>
<Func Name='ExtWeyl' Arg='V, lst'/>
<Returns> a list</Returns>
<Description>
This function returns a list of maximal vectors generating the socle
of the quotient <M>V/S</M> where <M>S</M> is the submodule of <A>V</A>
generated by the vectors in the given list <A>lst</A>.
<P/>
For example, with <A>V</A> as above, we have:

<Example>
gap> soc:= SocleWeyl(V);
[ y1*y2*y3*v0+y1^(2)*y2^(2)*v0 ]
gap> ExtWeyl(V, soc);
[ y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, y1*y2*y3^(2)*v0 ]
</Example>

Maximal vectors generating extensions are only determined modulo
<M>S</M>.  In some cases, the maximal vectors returned by
<K>ExtWeyl</K> are not the same as the maximal vectors returned by
<C>SocleWeyl(<A>V</A>/<A>S</A>)</C>. In order to properly detect the
splitting of some extension groups, the <K>ExtWeyl</K> function may in
some cases replace a maximal vector by a different choice of
representative. For example, the Weyl module of highest weight [2,0]
in characteristic 2 for Type <M>G_2</M> exhibits such a difference:

<Example>
gap> V:= WeylModule(2,[2,0],"G",2);
&lt;Type G2 Weyl module of highest weight [ 2, 0 ] at prime p = 2>
gap> S:= SocleWeyl(V);
[ y1*v0, y4*v0 ]
gap> e:= ExtWeyl(V,S);
[ y1*y6*v0+y3*y5*v0+y4^(2)*v0 ]
gap> SocleWeyl( QuotientWeylModule(V,SubWeylModule(V,S)) );
[ y4^(2)*v0 ]
</Example>

In this case, the vector <M>y_1 y_6 v_0+y_3y_5v_0+y_4^{(2)}v_0</M> is a
better choice of generator than <M>y_4^{(2)}v_0</M>. Both choices are
equivalent module the submodule generated by the socle, but the first
choice reveals that only one of the socle factors is extended, as one
sees by running <K>SubmoduleStructure</K> on this module. (I am indebted to
Yutaka Yoshii for finding this example and pointing out some bugs in
an earlier version of the &GAP; code.)
</Description>
</ManSection>


<ManSection>
<Func Name='MaximalSubmodule' Arg='V'/>
<Returns> a list</Returns>
<Description>
<K>MaximalSubmodule</K> returns a basis of weight vectors for the
(unique) maximal submodule of the given Weyl module <A>V</A>. The
corresponding quotient is irreducible, of the same highest weight as
<A>V</A>.

<Example>
gap> V:= WeylModule(2, [4,0], "A", 2); 
&ly;Type A2 Weyl module of highest weight [ 4, 0 ] at prime p = 2>
gap> Dim(V);                          
15
gap> max:= MaximalSubmodule(V);
[ y1*v0, y3*v0, y1*y3*v0, y1^(3)*v0, y1*y3^(2)*v0, y1^(2)*y3*v0, y3^(3)*v0, 
  y1^(3)*y3*v0, y1*y3^(3)*v0, y1^(2)*v0, y3^(2)*v0, y1^(2)*y3^(2)*v0 ]
gap> Length(max);
12
gap> Q:= QuotientWeylModule(V, max);
&lt;Quotient of Type A2 Weyl module of highest weight [ 4, 0 ] at prime p = 2>
gap> b:= BasisVecs(Q);
[ 1*v0, y1^(4)*v0, y3^(4)*v0 ]
gap> List(b, Weight);
[ [ 4, 0 ], [ -4, 4 ], [ 0, -4 ] ]
</Example>
</Description>
</ManSection>
</Section>

<Section Label='sec:maxvec'><Heading>Maximal and primitive vectors;
homomorphisms between Weyl modules</Heading>

A <E>maximal vector</E> is by definition a non-zero vector killed by
the action of the unipotent radical of the positive Borel subgroup;
see <Cite Key='Jantzen'/> for further details.  

<ManSection>
<Func Name='MaximalVectors' Arg='V'/>
<Func Name='MaximalVectors' Arg='V, lambda'/>
<Returns>a list</Returns>
<Description>
Suppose that <A>V</A> is a Weyl module or a quotient Weyl
module. These commands respectively return a list of linearly
independent vectors in <A>V</A> spanning the subspace of all maximal
vectors of <A>V</A>, or a list of linearly independent vectors
spanning the subspace of maximal vectors of the given weight space of
weight <A>lambda</A>. (Note that linear combinations of maximal
vectors are again maximal.)
<P/>
In case <A>V</A> is a Weyl module, each maximal vector of <A>V</A>
corresponds to a nontrivial homomorphism from the Weyl module of that
highest weight into <A>V</A>. Hence the above commands can be used to
determine the space <C>Hom(<A>W</A>, <A>V</A>)</C> for two given Weyl
modules <A>W</A>, <A>V</A>.

<Example>
gap> V:= WeylModule(2, [2,2,2], "A", 3);
&lt;Type A3 Weyl module of highest weight [ 2, 2, 2 ] at prime p = 2>
gap> m:= MaximalVectors(V);             
[ 1*v0, y1*v0, y2*v0, y3*v0, y1*y3*v0, y1*y2*y3*v0+y3*y4*v0+y6*v0, 
  y1*y2*y5*v0+y2*y3*y4*v0+y4*y5*v0, y1*y2*y4*v0, y2*y3*y5*v0, 
  y1*y2*y3*y4*v0+y1*y4*y5*v0, y1*y2*y3*y5*v0, y1*y2*y3*y4*y5*y6*v0 ]
gap> m:= MaximalVectors(V, [0,3,2]);   
[ y1*v0 ]
</Example>

Here are two examples where the space of maximal vectors for a
specified weight has dimension strictly greater than 1. As mentioned
at the beginning of the chapter, such examples generate a warning
message (which is safe to ignore in the two cases given below).

<Example>
gap> V:= WeylModule(2, [0,1,0,0], "D", 4); 
&lt;Type D4 Weyl module of highest weight [ 0, 1, 0, 0 ] at prime p = 2>
gap> m:= MaximalVectors(V);
********************************************************
** WARNING! Dimension > 1 detected
** in maximal vecs of weight [ 0, 0, 0, 0 ]
** in Weyl module of highest weight
** [ 0, 1, 0, 0 ]
********************************************************
[ 1*v0, y5*y10*v0+y6*y9*v0, y2*y11*v0+y5*y10*v0+y12*v0 ]
gap> List(m, Weight);
[ [ 0, 1, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ]
gap> V:= WeylModule(2, [0,1,0,0,0,0], "D", 6);
&lt;Type D6 Weyl module of highest weight [ 0, 1, 0, 0, 0, 0 ] at prime p = 2>
gap> m:= MaximalVectors(V);                   
********************************************************
** WARNING! Dimension > 1 detected
** in maximal vecs of weight [ 0, 0, 0, 0, 0, 0 ]
** in Weyl module of highest weight
** [ 0, 1, 0, 0, 0, 0 ]
********************************************************
[ 1*v0, y7*y28*v0+y8*y27*v0+y13*y25*v0+y18*y22*v0, y2*y29*v0+y7*y28*v0+y30*v0 
 ]
gap> List(m, Weight);                         
[ [ 0, 1, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0 ] ]
</Example>
</Description>
</ManSection>


Given a weight vector <A>v</A> in a Weyl module, or quotient Weyl
module, one can test whether or not the vector <A>v</A> is
maximal. 

<ManSection>
<Func Name='IsMaximalVector' Arg='V, v'/>
<Func Name='IsMaximalVector' Arg='V, lst, v'/>
<Returns>a list</Returns>
<Description>
In the second form <A>lst</A> must be a basis of weight vectors
for a submodule of <A>V</A>. The first form of the command returns
<K>true</K> iff <A>v</A> is maximal in <A>V</A>; the second form returns
<K>true</K> iff the image of <A>v</A> is maximal in the quotient
<A>V</A>/<A>S</A> where <A>S</A> is the submodule spanned by
<A>lst</A>.
</Description>
</ManSection>


If <A>V</A> is a Weyl module, a <E>primitive vector</E> in <A>V</A> is
a vector whose image in some sub-quotient is maximal (see <Cite
Key='Xi'/>). Maximal vectors are always primitive, by definition. The
(independent) primitive vectors are in bijective correspondence with
the composition factors of <A>V</A>.
<P/>
If <A>V</A> is a Weyl module, the command

<ManSection>
<Func Name='PrimitiveVectors' Arg='V'/>
<Returns>a list</Returns>
<Description>
This function returns a list of the primitive vectors of
<A>V</A>. This is the same list returned by <K>SubmoduleStructure</K>
but it should execute faster since it does not bother about computing
structure. For example:

<Example>
gap> V:= WeylModule(3, [3,3], "A", 2);
&lt;Type A2 Weyl module of highest weight [ 3, 3 ] at prime p = 3>
gap> p:= PrimitiveVectors(V);
[ y1*y2*y3*v0+y1^(2)*y2^(2)*v0, y1^(2)*y2*v0, -1*y1*y2^(2)*v0+y2*y3*v0, 
  y1*y2*y3^(2)*v0, y1*v0, y2*v0, y1^(3)*y2^(3)*v0+y3^(3)*v0, 1*v0 ]
</Example>

WARNING: If the dimension of <A>V</A> is large, this command can take a
very long time to execute.
</Description>
</ManSection>
</Section>


<Section Label='sec:submodules'><Heading>Submodules</Heading>

Given a vector <A>v</A> or a list <A>lst</A> of vectors, in a given
Weyl module or quotient Weyl module, <A>V</A>, one obtains a basis of
weight vectors for the submodule of <A>V</A> generated by <A>v</A> or
<A>lst</A> by the appropriate command listed below.

<ManSection>
<Func Name='SubWeylModule' Arg='V, v'/>
<Func Name='SubWeylModule' Arg='V, lst'/>
<Returns>a list</Returns>
<Description>
These functions return a list of linearly independent weight vectors
spanning the submodule generated by either the given vector <A>v</A>
or the given list <A>lst</A>.  WARNING: This can take a very long
time if the dimension of <A>V</A> is large.
<P/>
Here is an example, in which we find a submodule and compute the
corresponding quotient of the Weyl module:

<Example>
gap> V:= WeylModule(2, [8,0], "A", 2);
&lt;Type A2 Weyl module of highest weight [ 8, 0 ] at prime p = 2>
gap> m:= MaximalVectors(V);           
[ 1*v0, y1*v0, y1^(3)*y3^(2)*v0 ]
gap> List(m, Weight);                 
[ [ 8, 0 ], [ 6, 1 ], [ 0, 1 ] ]
gap> s:= SubWeylModule(V, m[2]);
[ y1*v0, y3*v0, y1*y3*v0, y1^(3)*v0, y1*y3^(2)*v0, y1^(5)*v0, y1*y3^(4)*v0, 
  y1^(2)*y3*v0, y3^(3)*v0, y1^(4)*y3*v0, y3^(5)*v0, y1^(3)*y3*v0, 
  y1*y3^(3)*v0, y1^(5)*y3*v0, y1*y3^(5)*v0, y1^(3)*y3^(2)*v0, y1^(7)*v0, 
  y1^(3)*y3^(4)*v0, y1^(5)*y3^(2)*v0, y1*y3^(6)*v0, y1^(2)*y3^(3)*v0, 
  y1^(6)*y3*v0, y1^(2)*y3^(5)*v0, y1^(4)*y3^(3)*v0, y3^(7)*v0, 
  y1^(3)*y3^(3)*v0, y1^(7)*y3*v0, y1^(3)*y3^(5)*v0, y1^(5)*y3^(3)*v0, 
  y1*y3^(7)*v0 ]
gap> Q:= QuotientWeylModule(V, s);
&lt;Quotient of Type A2 Weyl module of highest weight [ 8, 0 ] at prime p = 2>
gap> BasisVecs(Q);
[ 1*v0, y1^(2)*v0, y3^(2)*v0, y1^(4)*v0, y1^(2)*y3^(2)*v0, y1^(6)*v0, 
  y3^(4)*v0, y1^(4)*y3^(2)*v0, y1^(8)*v0, y1^(2)*y3^(4)*v0, y1^(6)*y3^(2)*v0, 
  y3^(6)*v0, y1^(4)*y3^(4)*v0, y1^(2)*y3^(6)*v0, y3^(8)*v0 ]
gap> Dim(Q);
15
</Example>

One can also construct sub-quotients (continuing the preceding
computation):

<Example>
gap> mm:= MaximalVectors(Q);
[ 1*v0, y1^(2)*v0 ]
gap> subq:= SubWeylModule(Q, mm[2]);
[ y1^(2)*v0, y3^(2)*v0, y1^(2)*y3^(2)*v0, y1^(6)*v0, y1^(2)*y3^(4)*v0, 
  y1^(4)*y3^(2)*v0, y3^(6)*v0, y1^(6)*y3^(2)*v0, y1^(2)*y3^(6)*v0 ]
gap> List(subq, Weight);
[ [ 4, 2 ], [ 6, -2 ], [ 2, 0 ], [ -4, 6 ], [ 0, -2 ], [ -2, 2 ], [ 2, -6 ], 
  [ -6, 4 ], [ -2, -4 ] ]
</Example>

Here, we have constructed a basis of weight vectors for the simple
socle of the quotient <A>Q</A>. 
</Description>
</ManSection>

<ManSection>
<Func Name='IsWithin' Arg='V, lst, v'/>
<Returns><K>true</K> or <K>false</K></Returns>
<Description>
Let <A>V</A> be a Weyl module or a quotient Weyl module. Given a list
<A>lst</A> of weight vectors forming a basis for a submodule, and a
vector <A>v</A>, the above command returns <K>true</K> iff the given
vector <A>v</A> lies within the submodule given by the basis
<A>lst</A>.
</Description>
</ManSection>
</Section>


<Section><Heading>Weights and weight spaces</Heading>

If <A>V</A> is a Weyl module or a quotient Weyl module, the following
commands are available.

<ManSection>
<Func Name='Weights' Arg='V'/>
<Func Name='DominantWeights' Arg='V'/>
<Func Name='WeightSpaces' Arg='V'/>
<Func Name='DominantWeightSpaces' Arg='V'/>
<Func Name='WeightSpace' Arg='V, lambda'/>
<Returns>a list</Returns>
<Description>
<C>Weights</C> returns a list of the weights of <A>V</A>, without
multiplicities; <C>DominantWeights</C> returns a list of the dominant
weights of <A>V</A>, again without multiplicities. 
<P/>
<C>WeightSpaces</C> returns a list consisting of each weight followed by a
basis of the corresponding weight space; <C>DominantWeightSpaces</C>
returns just the sublist containing the dominant weights and the
corresponding weight spaces. 
<P/>
Finally, <C>WeightSpace</C> returns a basis of the particular weight space
given by the specified weight <A>lambda</A>.

<Example>
gap> V:= WeylModule(2, [1,0,0], "A", 3);
&lt;Type A3 Weyl module of highest weight [ 1, 0, 0 ] at prime p = 2>
gap> Weights(V);
[ [ 1, 0, 0 ], [ -1, 1, 0 ], [ 0, -1, 1 ], [ 0, 0, -1 ] ]
gap> DominantWeights(V);
[ [ 1, 0, 0 ] ]
gap> WeightSpaces(V);
[ [ 1, 0, 0 ], [ 1*v0 ], [ -1, 1, 0 ], [ y1*v0 ], [ 0, -1, 1 ], [ y4*v0 ], 
  [ 0, 0, -1 ], [ y6*v0 ] ]
gap> DominantWeightSpaces(V);
[ [ 1, 0, 0 ], [ 1*v0 ] ]
gap> WeightSpace(V, [-1,1,0]);
[ y1*v0 ]
gap> WeightSpace(V, [0,1,0]); 
fail
</Example>

The last command prints <K>fail</K> because there are no weight vectors of
weight [0,1,0] in the indicated Weyl module.
</Description>
</ManSection>
</Section>
</Chapter>


<Chapter><Heading>Characters and decomposition numbers</Heading>

(Formal) characters can be computed for Weyl modules and simple
modules. In the latter case, this is done recursively using
Steinberg's tensor product theorem; the characters of the simple
modules of restricted highest weight are obtained by first computing
the maximal submodule and then forming the corresponding quotient.

<Section><Heading>Characters</Heading>

We now discuss the functions available for computing characters.

<ManSection>
<Func Name='Character' Arg='V'/>
<Returns>a list</Returns>
<Description>
Suppose that <A>V</A> is a given Weyl module or quotient Weyl module.
This function returns the formal character of <A>V</A>, in the form of
a list of weights and multiplicities (the multiplicity of each weight
follows the weight in the list). For example,

<Example>
gap> V:= WeylModule(3, [3,0], "A", 2);
&lt;Type A2 Weyl module of highest weight [ 3, 0 ] at prime p = 3>
gap> Character(V);
[ [ 3, 0 ], 1, [ 1, 1 ], 1, [ 2, -1 ], 1, [ -1, 2 ], 1, [ 0, 0 ], 1, 
  [ -3, 3 ], 1, [ 1, -2 ], 1, [ -2, 1 ], 1, [ -1, -1 ], 1, [ 0, -3 ], 1 ]
gap> S:= MaximalSubmodule(V);
[ y1*v0, 2*y1^(2)*v0, 2*y3*v0, y1*y3*v0, 2*y1^(2)*y3*v0, y3^(2)*v0, 
  2*y1*y3^(2)*v0 ]
gap> Character( QuotientWeylModule(V, S) );
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
</Example>

Of course, characters of Weyl modules are independent of the
characteristic.
</Description>
</ManSection>

<ManSection>
<Func Name='SimpleCharacter' Arg='p, wt, t, r'/>
<Func Name='SimpleCharacter' Arg='V, wt'/>
<Returns>a list</Returns>
<Description>
In the first form, the command <C>SimpleCharacter</C> returns the character
of the simple module of highest weight <A>wt</A> in characteristic
<A>p</A>, for the root system of Type <A>t</A> and rank <A>r</A>. In
the second form, <A>V</A> is an existing Weyl module and the data
<A>p</A>, <A>t</A>, and <A>r</A> are taken from the same data used to
define <A>V</A>.

<Example>
gap> SimpleCharacter(3, [3,0], "A", 2);    
[ [ 3, 0 ], 1, [ -3, 3 ], 1, [ 0, -3 ], 1 ]
</Example>
</Description>
</ManSection>


<ManSection>
<Func Name='Character' Arg='lst'/>
<Returns>a list</Returns>
<Description>
This function returns the character of the submodule (of a Weyl
module, or a quotient Weyl module) spanned by the independent weight
vectors in the given list <A>lst</A>.

<Example>
gap> V:= WeylModule(2, [4,0], "A", 2);
&lt;Type A2 Weyl module of highest weight [ 4, 0 ] at prime p = 2>
gap> m:= MaximalVectors(V);
[ 1*v0, y1*v0 ]
gap> simple:= SubWeylModule(V, m[2]);
[ y1*v0, y3*v0, y1*y3*v0, y1^(3)*v0, y1*y3^(2)*v0, y1^(2)*y3*v0, y3^(3)*v0, 
  y1^(3)*y3*v0, y1*y3^(3)*v0 ]
gap> Character(simple);
[ [ 2, 1 ], 1, [ 3, -1 ], 1, [ 1, 0 ], 1, [ -2, 3 ], 1, [ 0, -1 ], 1, 
  [ -1, 1 ], 1, [ 1, -3 ], 1, [ -3, 2 ], 1, [ -1, -2 ], 1 ]
</Example>

In the preceding example, we obtain the character of the simple socle
of the Type <M>A_2</M> Weyl module of highest weight [4,0], in
characteristic 2.
</Description>
</ManSection>


<ManSection>
<Func Name='DifferenceCharacter' Arg='c1, c2'/>
<Returns>a list</Returns>
<Description>
<C>DifferenceCharacter</C> returns the difference of two given characters,
or <K>fail</K> if the difference is not another character. The arguments
must be characters.
<P/>
In the following example, we compute the character of the maximal
submodule of the Weyl module of highest weight [6,0] for Type
<M>A_2</M> in characteristic 2.

<Example>
gap> ch1:= Character( WeylModule(2, [6,0], "A", 2) ); 
[ [ 6, 0 ], 1, [ 4, 1 ], 1, [ 5, -1 ], 1, [ 2, 2 ], 1, [ 3, 0 ], 1, [ 0, 3 ], 
  1, [ 4, -2 ], 1, [ 1, 1 ], 1, [ -2, 4 ], 1, [ 2, -1 ], 1, [ -1, 2 ], 1, 
  [ -4, 5 ], 1, [ 3, -3 ], 1, [ 0, 0 ], 1, [ -3, 3 ], 1, [ -6, 6 ], 1, 
  [ 1, -2 ], 1, [ -2, 1 ], 1, [ -5, 4 ], 1, [ 2, -4 ], 1, [ -1, -1 ], 1, 
  [ -4, 2 ], 1, [ 0, -3 ], 1, [ -3, 0 ], 1, [ 1, -5 ], 1, [ -2, -2 ], 1, 
  [ -1, -4 ], 1, [ 0, -6 ], 1 ]
gap> ch2:= SimpleCharacter(2, [6,0], "A", 2);        
[ [ 6, 0 ], 1, [ -2, 4 ], 1, [ 2, -4 ], 1, [ 2, 2 ], 1, [ -6, 6 ], 1, 
  [ -2, -2 ], 1, [ 4, -2 ], 1, [ -4, 2 ], 1, [ 0, -6 ], 1 ]
gap> d:= DifferenceCharacter(ch1, ch2);              
[ [ 4, 1 ], 1, [ 5, -1 ], 1, [ 3, 0 ], 1, [ 0, 3 ], 1, [ 1, 1 ], 1, 
  [ 2, -1 ], 1, [ -1, 2 ], 1, [ -4, 5 ], 1, [ 3, -3 ], 1, [ 0, 0 ], 1, 
  [ -3, 3 ], 1, [ 1, -2 ], 1, [ -2, 1 ], 1, [ -5, 4 ], 1, [ -1, -1 ], 1, 
  [ 0, -3 ], 1, [ -3, 0 ], 1, [ 1, -5 ], 1, [ -1, -4 ], 1 ]
</Example>
</Description>
</ManSection>
</Section>


<Section><Heading>Decomposition numbers</Heading>

We can also compute decomposition numbers of Weyl modules.

<ManSection>
<Func Name='DecompositionNumbers' Arg='V'/>
<Returns>a list</Returns>
<Description>
If <A>V</A> is a given Weyl module, this command returns a list of
highest weights of the composition factors of <A>V</A>, along with
their corresponding multiplicities.

<Example>
gap> V:= WeylModule(2, [8,0], "A", 2);
&lt;Type A2 Weyl module of highest weight [ 8, 0 ] at prime p = 2>
gap> DecompositionNumbers(V);
[ [ 8, 0 ], 1, [ 6, 1 ], 1, [ 4, 2 ], 1, [ 0, 4 ], 1, [ 0, 1 ], 1 ]
gap> V:= WeylModule(3, [1,1], "A", 2);
&lt;Type A2 Weyl module of highest weight [ 1, 1 ] at prime p = 3>
gap> DecompositionNumbers(V);         
[ [ 1, 1 ], 1, [ 0, 0 ], 1 ]
</Example>
</Description>
</ManSection>
</Section>


<Section><Heading>Decomposing tensor products</Heading>

One can also decompose tensor products of modules whose characters are
known, using the following functions.

<ManSection>
<Func Name='ProductCharacter' Arg='a, b'/>
<Func Name='DecomposeCharacter' Arg='ch, p, t, r'/>
<Returns>a list</Returns>
<Description>
The function <C>ProductCharacter</C> returns the product of two given
characters, and <C>DecomposeCharacter</C> computes the decomposition
numbers of a given character <A>ch</A>, relative to simple characters
in characteristic <A>p</A> for a given type and rank.
<P/>
In the following example, we compute the multiplicities of simple
composition factors in the tensor square of the natural representation
for the group of Type <M>A_4</M> in characteristic 2.

<Example>
gap> ch:= SimpleCharacter(2, [1,0,0,0], "A", 4);
[ [ 1, 0, 0, 0 ], 1, [ -1, 1, 0, 0 ], 1, [ 0, -1, 1, 0 ], 1, [ 0, 0, -1, 1 ], 
  1, [ 0, 0, 0, -1 ], 1 ]
gap> chsquared:= ProductCharacter(ch, ch);
[ [ 2, 0, 0, 0 ], 1, [ 0, 1, 0, 0 ], 2, [ 1, -1, 1, 0 ], 2, [ 1, 0, -1, 1 ], 
  2, [ 1, 0, 0, -1 ], 2, [ -2, 2, 0, 0 ], 1, [ -1, 0, 1, 0 ], 2, 
  [ -1, 1, -1, 1 ], 2, [ -1, 1, 0, -1 ], 2, [ 0, -2, 2, 0 ], 1, 
  [ 0, -1, 0, 1 ], 2, [ 0, -1, 1, -1 ], 2, [ 0, 0, -2, 2 ], 1, 
  [ 0, 0, -1, 0 ], 2, [ 0, 0, 0, -2 ], 1 ]
gap> DecomposeCharacter(chsquared, 2, "A", 4);
[ [ 2, 0, 0, 0 ], 1, [ 0, 1, 0, 0 ], 2 ]
</Example>
</Description>
</ManSection>
</Section>
</Chapter>


<Chapter><Heading>Schur algebras and Symmetric Groups</Heading>

In principle, the decomposition numbers for the algebraic group
<M>{\rm SL}_n</M> of Type <M>A_{n-1}</M> determine the decomposition
numbers for Schur algebras, and thus determine also the decomposiotion
numbers for symmetric groups. People working with Schur algebras and
symmetric groups often prefer to use partitions to label highest
weights. Of course, it is trivial to convert between <M>{\rm SL}_n</M>
weight and partition notation. This section covers functions that
perform such conversions, and various other functions for Schur
algebras and symmetric groups.

<Section><Heading>Compositions and Weights</Heading>

A <E>composition</E> of degree <M>r</M> is a finite sequence <M>c =
[c_1, \dots, c_n]</M> of non-negative integers which sum to <M>r</M>.
The number <M>n</M> of parts of <M>c</M> is called its
<E>length</E>. One may identify the set of compositions of length
<M>n</M> with the set of <E>polynomial</E> weights of the algebraic
group <M>{\rm GL}_n</M>.
<P/>
Note that a composition is a partition if and only if it is a dominant
weight relative to the diagonal maximal torus in <M>{\rm GL}_n</M>.


<ManSection>
<Func Name='CompositionToWeight' Arg='c'/>
<Func Name='WeightToComposition' Arg='r, wt'/>
<Returns>a list</Returns>
<Description>
<C>CompositionToWeight</C> converts a given list <A>c</A> (of length
<A>n</A>) into an <M>{\rm SL}_n</M> weight, by taking successive
differences in the parts of <A>c</A>. This produces a list of length
<M>n-1</M>.
<P/>
<C>WeightToComposition</C> does the reverse operation, padding with zeros
if necessary in order to return a composition of degree <A>r</A>. The
degree must be specified since it is not uniquely determined by the
given weight. Note that degree is unique modulo <A>n</A>. The length
<A>n</A> of the output is always one more than the length of the
input.
<P/>
As a special case, these operations take partitions to dominant
weights, and vice versa.

<Example>
gap> wt:= CompositionToWeight( [3,3,2,1,1,0,0] );
[ 0, 1, 1, 0, 1, 0 ]
gap> WeightToComposition(10, wt);
[ 3, 3, 2, 1, 1, 0, 0 ]
gap> WeightToComposition(17, wt);
[ 4, 4, 3, 2, 2, 1, 1 ]
</Example>
</Description>
</ManSection>



<ManSection>
<Func Name='BoundedPartitions' Arg='n, r, s'/>
<Func Name='BoundedPartitions' Arg='n, r'/>
<Returns>a list</Returns>
<Description>
<C>BoundedPartitions(<A>n</A>,<A>r</A>,<A>s</A>)</C> returns a list of
<A>n</A>-part partitions of degree <A>r</A>, where each part lies in
the interval [0,<A>s</A>]. Note that some parts of the partition may
be equal to zero.
<P/>
<C>BoundedPartitions(<A>n</A>,<A>r</A>)</C> is equivalent to
<C>BoundedPartitions(<A>n</A>,<A>r</A>,<A>r</A>)</C>, which returns a list
of all <A>n</A>-part partitions of degree <A>r</A>.

<Example>
gap> BoundedPartitions(4,3,2);           
[ [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
gap> BoundedPartitions(4,3,3);
[ [ 3, 0, 0, 0 ], [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
gap> BoundedPartitions(4,3);
[ [ 3, 0, 0, 0 ], [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
gap> BoundedPartitions(4,4,4);
[ [ 4, 0, 0, 0 ], [ 3, 1, 0, 0 ], [ 2, 2, 0, 0 ], [ 2, 1, 1, 0 ], 
  [ 1, 1, 1, 1 ] ]
</Example>

Note that running <C>BoundedPartitions(<A>n</A>,<A>n</A>,<A>n</A>)</C>
produces a list of all partitions of <A>n</A>.
</Description>
</ManSection>
</Section>

<Section><Heading>Schur Algebras</Heading>

<ManSection>
<Func Name='SchurAlgebraWeylModule' Arg='p, lambda'/>
<Returns>a Weyl module</Returns>
<Description>
<C>SchurAlgebraWeylModule</C> returns the Weyl module of highest
weight <A>wt</A> in characteristic <A>p</A>, regarded as a module for
<M>{\rm GL}_n</M> where <A>n</A> is the length of the given partition
<A>lambda</A>.

<Example>
gap> V:= SchurAlgebraWeylModule(3, [2,2,1,1,0]);
&lt;Schur algebra Weyl module of highest weight [ 2, 2, 1, 1, 0 ] at prime p = 3>
</Example>
</Description>
</ManSection>


<ManSection>
<Func Name='DecompositionNumbers' Arg='V'/>
<Returns>a list</Returns>
<Description>
<C>DecompositionNumbers</C> returns the decomposition numbers of a given
Schur algebra Weyl module <A>V</A>, using partition notation for dominant
weights.

<Example>
gap> V:= SchurAlgebraWeylModule(3, [2,2,1,1,0]);
&lt;Schur algebra Weyl module of highest weight [ 2, 2, 1, 1, 0 ] at prime p = 3>
gap> DecompositionNumbers(V);
[ [ 2, 2, 1, 1, 0 ], 1 ]
</Example>

The above example shows an irreducible Weyl module for <M>{\rm
GL}_5</M>. Here is a more interesting example:

<Example>
gap> V:= SchurAlgebraWeylModule(2, [4,2,1,1,0]);
&lt;Schur algebra Weyl module of highest weight [ 4, 2, 1, 1, 0 ] at prime p = 2>
gap> DecompositionNumbers(V);                   
[ [ 4, 2, 1, 1, 0 ], 1, [ 3, 3, 1, 1, 0 ], 1, [ 3, 2, 2, 1, 0 ], 1, 
  [ 4, 1, 1, 1, 1 ], 1, [ 2, 2, 2, 2, 0 ], 1, [ 2, 2, 2, 1, 1 ], 1 ]
</Example>
</Description>
</ManSection>


<ManSection>
<Func Name='SchurAlgebraDecompositionMatrix' Arg='p, n, r'/>
<Returns>a list of lists</Returns>
<Description>
<C>SchurAlgebraDecompositionMatrix</C> returns the decomposition
matrix for a Schur algebra <M>S(n,r)</M> in characteristic
<A>p</A>. The rows and columns of the matrix are indexed by the
partitions produced by <C>BoundedPartitions(<A>n</A>,<A>r</A>)</C>.

<Example>
gap> SchurAlgebraDecompositionMatrix(2, 4, 5);
[ [ 1, 0, 1, 1, 0, 0 ], [ 0, 1, 0, 0, 0, 1 ], [ 0, 0, 1, 1, 1, 0 ], 
  [ 0, 0, 0, 1, 1, 0 ], [ 0, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ]
gap> BoundedPartitions(4,5);
[ [ 5, 0, 0, 0 ], [ 4, 1, 0, 0 ], [ 3, 2, 0, 0 ], [ 3, 1, 1, 0 ], 
  [ 2, 2, 1, 0 ], [ 2, 1, 1, 1 ] ]
</Example>
</Description>
</ManSection>
</Section>


<Section><Heading>Symmetric groups</Heading>

Symmetric group decomposition numbers in positive characteristic may
be obtained from corresponding decomposition numbers for a Schur
algebra Weyl module, by means of the well known <Q>Schur
functor</Q>. (See for instance Chapter 6 of <Cite Key='Green'/> for
details.)
<P/>
This is not a very efficient method to calculate those decomposition
numbers. People needing such numbers for large partitions should use
other methods. The approach taken here, through Schur algebras, is
reasonably fast only up to about degree 7 at present.

<ManSection>
<Func Name='SymmetricGroupDecompositionNumbers' Arg='p, mu'/>
<Returns>a list</Returns>
<Description>
<C>SymmetricGroupDecompositionNumbers</C> returns a list of the
decomposition numbers <M>[S_\mu: D_\lambda]</M> for the dual Specht
module <M>S_\mu</M> labeled by a partition <M>\mu</M>, in
characteristic <A>p</A>. The simple modules <M>D_\lambda</M> are
labeled by <A>p</A>-restricted partitions of the same degree as
<M>\mu</M>.

<Example>
gap> SymmetricGroupDecompositionNumbers(3, [3,2,1]);
[ [ 3, 2, 1 ], 1, [ 2, 2, 2 ], 1, [ 3, 1, 1, 1 ], 1, [ 2, 1, 1, 1, 1 ], 1, 
  [ 1, 1, 1, 1, 1, 1 ], 1 ]
</Example>
</Description>
</ManSection>


<ManSection>
<Func Name='SymmetricGroupDecompositionMatrix' Arg='p, n'/>
<Returns>a list of lists</Returns>
<Description>
<C>SymmetricGroupDecompositionMatrix</C> returns the decomposition
matrix for the symmetric group on <A>n</A> letters, in characteristic
<A>p</A>. The rows of the matrix are labeled by partitions of <A>n</A>
and columns are labeled by the <A>p</A>-restricted partitions of
<A>n</A>.
<P/>
To obtain lists of the row and column labels use the following functions.
</Description>
</ManSection>


<ManSection>
<Func Name='AllPartitions' Arg='n'/>
<Func Name='pRestrictedPartitions' Arg='p, n'/>
<Returns>a list</Returns>
<Description>
These functions respectively return a list of all partitions of
<A>n</A>, and a list of all <A>p</A>-restricted partitions of
<A>n</A>. Note that trailing zeros are omitted in such
partitions. (&GAP; has a built-in <C>Partitions</C> function that also
gives all the partitions of <A>n</A>, but the ordering is different
from the ordering in <C>AllPartitions</C> above. To correctly
interpret row labels in the decomposition matrix, one must use the
ordering in <C>AllPartitions</C>.)
<P/>
For example, we compute the decomposition matrix for the symmetric
group on 5 letters in characteristic 2, along with the row and column
labels for the matrix:

<Example>
gap> SymmetricGroupDecompositionMatrix(2, 5);
[ [ 0, 0, 1 ], [ 0, 1, 0 ], [ 1, 0, 1 ], [ 1, 0, 2 ], [ 1, 0, 1 ], 
  [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> AllPartitions(5);
[ [ 5 ], [ 4, 1 ], [ 3, 2 ], [ 3, 1, 1 ], [ 2, 2, 1 ], [ 2, 1, 1, 1 ], 
  [ 1, 1, 1, 1, 1 ] ]
gap> pRestrictedPartitions(2,5);
[ [ 2, 2, 1 ], [ 2, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
</Example>
</Description>
</ManSection>
</Section>


<Section><Heading>The Mullineux correspondence</Heading>

Computing symmetric group decomposition numbers by means of the Schur
functor naturally produces the decomposition numbers <M>[S_\mu:
D_\lambda]</M> for partitions <M>\mu</M> and <M>p</M>-restricted
partitions <M>\lambda</M>. Here <M>S^\mu</M> is the dual Specht module
labeled by <M>\mu</M> and <M>D_\lambda</M> the dual simple module
labeled by <M>\mu</M>.
<P/>
Let <M>\lambda'</M> be the conjugate partition of a partition
<M>\lambda</M>, obtained by transposing rows and columns of the
corresponding Young diagram. We have <M>(S^{\mu})^\ast \simeq
S_\mu</M> for a partition <M>\mu</M> and <M>D^\lambda \otimes {\rm
sgn} \simeq D_{\lambda'}</M> for a <M>p</M>-regular partition
<M>\lambda</M>, where <M>S^\mu</M> is the usual Specht module and
<M>D^\lambda</M> the usual simple module, using notation in accord
with <Cite Key='James'/>. The notation <M>{\rm sgn}</M> refers to the
sign representation.
<P/>
Thus it follows that <M>[S_\mu: D_\lambda] = [S^\mu: D^{{\rm
Mull}(\lambda')}]</M> if <M>\lambda</M> is <M>p</M>-restricted. So by
sending <M>\lambda \to {\rm Mull}(\lambda')</M>, one obtains the
column labels for the decomposition matrix that appear in <Cite
Key='James'/>.

<ManSection>
<Func Name='Mullineux' Arg='p, mu'/>
<Returns>a list</Returns>
<Description>
<C>Mullineux</C> returns the partition <M>{\rm Mull}(\mu)</M> corresponding
to a given <M>p</M>-regular partition <M>\mu</M> under the Mullineux
map. This means by definition that <M>D^\mu \otimes {\rm sgn} \simeq
D^{{\rm Mull}(\mu)}</M>.

<Example>
gap> Mullineux(3, [5,4,1,1]);
[ 9, 2 ]
gap> Mullineux(3, [9,2]);    
[ 5, 4, 1, 1 ]
</Example>
</Description>
</ManSection>



<ManSection>
<Func Name='pRegularPartitions' Arg='p, n'/>
<Returns>a list</Returns>
<Description>
<C>pRegularPartitions</C> returns a list of the <M>p</M>-regular partitions
of <A>n</A>, in bijection with the list of <M>p</M>-restricted partitions
of <A>n</A> produced by <C>pRestrictedPartitions</C>, using the bijection
<M>\lambda \to {\rm Mull}(\lambda')</M>.  Thus, to read a symmetric
group decomposition matrix using <M>p</M>-regular partition notation,
one uses the output of <C>pRegularPartitions</C> to index the columns of
the matrix.

<Example>
gap> SymmetricGroupDecompositionMatrix(3, 5);
[ [ 0, 0, 1, 0, 0 ], [ 1, 0, 0, 0, 0 ], [ 1, 0, 0, 0, 1 ], [ 0, 1, 0, 0, 0 ], 
  [ 0, 0, 1, 1, 0 ], [ 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 1 ] ]
gap> AllPartitions(5);                       
[ [ 5 ], [ 4, 1 ], [ 3, 2 ], [ 3, 1, 1 ], [ 2, 2, 1 ], [ 2, 1, 1, 1 ], 
  [ 1, 1, 1, 1, 1 ] ]
gap> pRegularPartitions(3, 5);
[ [ 4, 1 ], [ 3, 1, 1 ], [ 5 ], [ 2, 2, 1 ], [ 3, 2 ] ]
</Example>

In the above example, we computed a decomposition matrix in
characteristic 3 for the symmetric group on 5 letters, along with
labels for its rows and columns, using <M>p</M>-regular partitions to
label the columns. If one wants instead to use <M>p</M>-restricted
column labels, one needs to run:

<Example>
gap> pRestrictedPartitions(3, 5);
[ [ 3, 2 ], [ 3, 1, 1 ], [ 2, 2, 1 ], [ 2, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
</Example>

from the preceding section, to see the correspondence. 
</Description>
</ManSection>
</Section>


<Section><Heading>Miscellaneous functions for partitions</Heading>

Here are a few additional miscellaneous functions useful for computing
with partitions.

<ManSection>
<Func Name='Conjugate' Arg='mu'/>
<Returns>a list</Returns>
<Description>
<C>Conjugate</C> returns the conjugate partition <M>\mu'</M> of its input
<M>\mu</M>. The Young diagram of <M>\mu'</M> is obtained from that of
<M>\mu</M> by transposing rows and columns. For example,

<Example>
gap> Conjugate( [4,4,2,1] );
[ 4, 3, 2, 2 ]
gap> Conjugate( [4,3,2,2] );
[ 4, 4, 2, 1 ]
</Example>
</Description>
</ManSection>


<ManSection>
<Func Name='pRestricted' Arg='p, mu'/>
<Func Name='pRegular' Arg='p, mu'/>
<Returns><K>true</K> or <K>false</K></Returns>
<Description>
<C>pRestricted</C> returns <K>true</K> iff the partition <A>mu</A> is
<M>p</M>-restricted (succesive differences <M>\mu_i - \mu_{i+1}</M>
are strictly bounded above by <M>p</M>); similarly <C>pRegular</C>
returns <K>true</K> iff the partition <A>mu</A> is <M>p</M>-regular
(equivalently, the conjugate of <A>mu</A> is <M>p</M>-restricted).

<Example>
gap> pRestricted(3, [6,6,6,4,4,2,1,1]);
true
gap> pRestricted(3, [6,3,1,1]);
false
gap> pRegular(3, [8,6,5,5,3,3]);       
true
gap> pRegular(3, [3,3,3,2,2,1,1]);
false
</Example>
</Description>
</ManSection>

</Section>
</Chapter>

</Body>


<Bibliography Databases="weyl" />
<TheIndex/>

</Book>
